{"meta":{"title":"Welcome | 张亚超的技术博客YACHAO'Blog","subtitle":"每一个不起眼的瞬间都是对生命的辜负！","description":"每一个不起眼的瞬间都是对生命的辜负！","author":"张亚超","url":"https://devchao.com"},"pages":[{"title":"","date":"2016-03-16T02:11:40.000Z","updated":"2015-09-02T02:59:40.000Z","comments":true,"path":"404.html","permalink":"https://devchao.com/404.html","excerpt":"","text":""},{"title":"about","date":"2015-09-07T02:28:17.000Z","updated":"2015-11-27T06:18:51.000Z","comments":true,"path":"about.html","permalink":"https://devchao.com/about.html","excerpt":"","text":"about me ####每个不起眼的瞬间都是对生命的辜负。"}],"posts":[{"title":"Hexo自定义网站升级为https","slug":"Hexo自定义网站升级为https","date":"2017-05-20T05:09:20.000Z","updated":"2017-05-20T05:13:37.000Z","comments":true,"path":"2017/05/20/Hexo自定义网站升级为https/","link":"","permalink":"https://devchao.com/2017/05/20/Hexo自定义网站升级为https/","excerpt":"","text":"前言最近发现，各大网站好像已经开始全站使用HTTPS，看着浏览器地址栏左边有着一把绿色的小锁，好像是一件很酷的事情。国内的网络环境好像越来越差，除了学会科学上网之外，好像也难免会遇到通讯服务商在网站上加上小广告的问题。随着不断了解计算机的知识，安全概念也越来越重。看着某某网站又被脱裤，一不小心自己的隐私可能就泄露出去了。今天是周末，也想给自己的博客加上把绿色的小锁HTTPS。 什么是HTTPSHTTPS全称Hypertext Transfer Protocol Secure 超文本安全协议。也就是HTTP加上安全传输层协议TSL/SSL。介于HTTP层与TCP层之间的一层安全协议。通过安全认证，可以避免HTTP中间人攻击，信息污染，信息劫持等问题。详细信息的话腾讯Bugly的文章全站HTTPS来了介绍得很详细。HTTPS基础原理，通信过程，在这篇文章里都有详细地讲到。 给博客加上HTTPS数字证书通过上述的HTTPS介绍，可以知道如果我们要给让博客的协议变成HTTPS，就需要有CA认可的证书才可以，一般这样子的证书是需要自己进行购买和申请认证的。简单RSA非对称性的加密算法是无法避免中间人攻击的。存在着中间人攻击和信息抵赖的风险。所以我这里所采用的方法是用，Cloudflare所提供的CDN来作为HTTPS的接入口。 CDN什么是CDN? CDN的全称就是Content Delivery Network，内容分发网络。其最基本的思路就是，用户在访问一个网站的时候，不直接访问这个网站的服务器，CDN系统会根据地理位置，将用户重新导向离其最近的CDN服务器。网站的内容在这个CDN服务器上会有相应的缓存，从而使用户更快地访问到所需要的内容，可以减少网络拥堵的情况，也可以减轻网站的服务器承受太大的访问量，以及带宽不足的情况。 主要步骤 注册Cloudflare，添加个人网站，根据指引一步步添加自己的网站。 获取Cloudflare的Domain Name Server。(alla.ns.cloudflare.com和vin.ns.cloudflare.com) 在域名提供商处修改自己域名的Domain Name Server为2所获取的DNS 在Cloudflare &gt; DNS中添加三条如下记录： A记录: 将一个域名指向一个ipv4的地址 AAAA记录: 将一个域名指向一个ipv6的地址 CNAME记录: 将一个域名指向另一个域名 PS: 填写A记录时Name字段输入@就会显示为你的网址,我的是devchao.com,CNAME字段的Value字段需要填写为你需要只想的域名 更改Cloudflare &gt; Crypto &gt; SSL 选择 Flexible。(加密方式有三种：Flexible、Full SSL 、 Full SSL(strict),这里选择Flexible) 更改Cloudflare &gt; Crypto &gt; Automatic HTTPS Rewrites 打开开关 flexible的SSL加密方式解析 There is an encrypted connection between your website visitors and Cloudflare, but not from Cloudflare to your server. There is an encrypted connection between your website visitors and Cloudflare, but not from Cloudflare to your server. Visitors will see the SSL lock icon in their browser Flexible SSL : 服务器与CDN在通信过程中的信息是没有加密的,因为我使用的git page 以及没有购买相应的证书，所以没法再服务器上部署SSL。所以CDN与服务器之间的通信就不是加密的通信。 在cloudflare上的Page Rules设置中，添加上一条规则使得通过http协议的访问也会强制跳转到https上。 全站https要做到成功让这个博客满足https的要求，在博客所使用所有的图片自然也是要使用https的链接才行的，只要网站上所使用的资源不是全部通过https的就存在着安全的风险。且网站会被chrome等浏览器认为是不安全的。 这里所使用的是新浪微博的图床，在chrome商店可以找到对应的插件。在左下角有的https的选项，只要勾选上了就可以默认生成https的图片链接了。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://devchao.com/tags/Hexo/"}]},{"title":"change-app-icon","slug":"change-app-icon","date":"2017-05-15T05:39:23.000Z","updated":"2017-05-15T06:45:09.000Z","comments":true,"path":"2017/05/15/change-app-icon/","link":"","permalink":"https://devchao.com/2017/05/15/change-app-icon/","excerpt":"","text":"change app icon本文教成将会一步步教你如何改变app图标，以下面两张图标(newicon2.png 120px X 120px , newicon@2x.png 180px X 180px)为例。 1.设置plist:在info-plsit中的Source Code中添加如下键值对。 123456789101112131415161718192021222324252627282930313233&lt;key&gt;CFBundleIcons&lt;/key&gt; &lt;dict&gt; &lt;key&gt;CFBundleAlternateIcons&lt;/key&gt; &lt;dict&gt; &lt;key&gt;newicon&lt;/key&gt; &lt;dict&gt; &lt;key&gt;CFBundleIconFiles&lt;/key&gt; &lt;array&gt; &lt;string&gt;newicon&lt;/string&gt; &lt;/array&gt; &lt;key&gt;UIPrerenderedIcon&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;key&gt;newicon2&lt;/key&gt; &lt;dict&gt; &lt;key&gt;CFBundleIconFiles&lt;/key&gt; &lt;array&gt; &lt;string&gt;newicon2&lt;/string&gt; &lt;/array&gt; &lt;key&gt;UIPrerenderedIcon&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;key&gt;CFBundlePrimaryIcon&lt;/key&gt; &lt;dict&gt; &lt;key&gt;CFBundleIconFiles&lt;/key&gt; &lt;array&gt; &lt;string&gt;&lt;/string&gt; &lt;/array&gt; &lt;key&gt;UIPrerenderedIcon&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;/dict&gt; 配置好的Property plsit如下图: 解释 CFBundleAlternateIcons 代表要修改的图标键，是一个字典类型，其中的每一个字典代表一个item的描述。并且这个字典的key必须是图片的名字，还要和CFBundleIconFiles的内容一样 UIPrerenderedIcon：指定应用程序的图标是否包含闪光效果（shine effect）,如果icon已经有这个效果，就把这个属性设置为YES来防止系统再次添加相同效果。如果设置为NO（默认值），iOS系统会自动添加这个效果。然而，并没有什么效果!! CFBundleIcons 配置app的图标。如果你要适配ipad需要在plist中再次加入CFBundleIcons~ipad键，其他配置同上。 我配置好的plist如下所示： 2.调用Apple的API 新建一个Single view application,在ViewController的View上添加一个Button添加一个事件如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647- (IBAction)changeAppIcon:(id)sender &#123; UIButton *button = (UIButton *)sender; button.selected = !button.selected; if (![self checkSuportChangeAppIcon]) &#123;//检查设备系统版本是否是iOS 10.3之后的 [self alertMessage:@&quot;Your system version was lower iOS 10.3.0,don&apos;t surport change app icon.&quot;]; &#125; if (![UIApplication sharedApplication].supportsAlternateIcons) &#123;//检查app是否支持改变app icon [self alertMessage:@&quot;Your application don&apos;t surport change app icon.&quot;]; &#125; NSString *icon = button.selected ? @&quot;newicon&quot; : @&quot;newicon2&quot;; [self changeToIcon:icon];//该变app icon &#125;-(BOOL)checkSuportChangeAppIcon&#123; NSString * systemVersion = [UIDevice currentDevice].systemVersion; if ([systemVersion floatValue] &gt;= 10.3f) &#123; return YES; &#125; return NO;&#125;/** 改变app icon @param icon iconName */-(void)changeToIcon:(NSString *)icon&#123; [[UIApplication sharedApplication] setAlternateIconName:icon completionHandler:^(NSError * _Nullable error) &#123; if (error) &#123; [self alertMessage:error.description]; &#125; &#125;];&#125;-(void)alertMessage:(NSString *)message&#123; UIAlertController *alertVC = [UIAlertController alertControllerWithTitle:@&quot;提示&quot; message:message preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *action = [UIAlertAction actionWithTitle:@&quot;好的&quot; style:UIAlertActionStyleDefault handler:nil]; [alertVC addAction:action]; [self presentViewController:alertVC animated:YES completion:nil];&#125; 下载代码 参考: 官方文档 http://www.cocoachina.com/ios/20170502/19152.html 技术交流群:494826724","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"CADisplayLink","slug":"CADisplayLink","date":"2017-05-03T05:59:39.000Z","updated":"2017-05-03T06:00:09.000Z","comments":true,"path":"2017/05/03/CADisplayLink/","link":"","permalink":"https://devchao.com/2017/05/03/CADisplayLink/","excerpt":"","text":"CADisplayLink ##什么是CADisplayLink CADisplayLink是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器。我们在应用中创建一个新的 CADisplayLink 对象，把它添加到一个runloop中，并给它提供一个 target 和selector 在屏幕刷新的时候调用。 一但 CADisplayLink 以特定的模式注册到runloop之后，每当屏幕需要刷新的时候，runloop就会调用CADisplayLink绑定的target上的selector，这时target可以读到 CADisplayLink 的每次调用的时间戳，用来准备下一帧显示需要的数据。例如一个视频应用使用时间戳来计算下一帧要显示的视频数据。在UI做动画的过程中，需要通过时间戳来计算UI对象在动画的下一帧要更新的大小等等。 在添加进runloop的时候我们应该选用高一些的优先级，来保证动画的平滑。可以设想一下，我们在动画的过程中，runloop被添加进来了一个高优先级的任务，那么，下一次的调用就会被暂停转而先去执行高优先级的任务，然后在接着执行CADisplayLink的调用，从而造成动画过程的卡顿，使动画不流畅。 duration属性提供了每帧之间的时间，也就是屏幕每次刷新之间的的时间。我们可以使用这个时间来计算出下一帧要显示的UI的数值。但是duration只是个大概的时间，如果CPU忙于其它计算，就没法保证以相同的频率执行屏幕的绘制操作，这样会跳过几次调用回调方法的机会。 frameInterval属性是可读可写的NSInteger型值，标识间隔多少帧调用一次selector 方法，默认值是1，即每帧都调用一次。如果每帧都调用一次的话，对于iOS设备来说那刷新频率就是60HZ也就是每秒60次，如果将 frameInterval 设为2 那么就会两帧调用一次，也就是变成了每秒刷新30次。我们通过pause属性开控制CADisplayLink的运行。当我们想结束一个CADisplayLink的时候，应该调用-(void)invalidate从runloop中删除并删除之前绑定的 target跟selector另外CADisplayLink 不能被继承。 ##CADisplayLink 与 NSTimer 有什么不同 iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。 NSTimer的精确度就显得低了点，比如NSTimer的触发时间到的时候，runloop如果在阻塞状态，触发时间就会推迟到下一个runloop周期。并且 NSTimer新增了tolerance属性，让用户可以设置可以容忍的触发的时间的延迟范围。 CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。在UI相关的动画或者显示内容使用 CADisplayLink比起用NSTimer的好处就是我们不需要在格外关心屏幕的刷新频率了，因为它本身就是跟屏幕刷新同步的。 ##CADisplayLink使用的例子 12345678910111213self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(updateTextColor)];self.displayLink.paused = YES;[self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];-(void)updateTextColor&#123;&#125;- (void)startAnimation&#123; self.beginTime = CACurrentMediaTime(); self.displayLink.paused = NO;&#125;- (void)stopAnimation&#123; self.displayLink.paused = YES; [self.displayLink invalidate]; self.displayLink = nil;&#125; ##给非UI对象添加动画效果 我们知道动画效果就是一个属性的线性变化，比如UIView 动画的 EasyIn EasyOut 。通过数值按照不同速率的变化我们能生成更接近真实世界的动画效果。我们也可以利用这个特性来使一些其他属性按照我们期望的曲线变化。比如当播放视频时关掉视频的声音我可以通过CADisplayLink来实现一个 EasyOut的渐出效果：先快速的降低音量，在慢慢的渐变到静音。 ##注意 通常来讲：iOS设备的刷新频率事60HZ也就是每秒60次。那么每一次刷新的时间就是1/60秒 大概16.7毫秒。当我们的frameInterval值为1的时候我们需要保证的是 CADisplayLink调用的｀target｀的函数计算时间不应该大于 16.7否则就会出现严重的丢帧现象。 在mac应用中我们使用的不是CADisplayLink而是 CVDisplayLink它是基于C接口的用起来配置有些麻烦但是用起来还是很简单的。 apple官方DEMO CADisplayLink Class Reference 一个文字渐变效果的动画开源库 技术交流群:494826724","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"Silent-Remote-Notification","slug":"Silent-Remote-Notification","date":"2017-04-24T04:59:38.000Z","updated":"2017-04-24T05:00:10.000Z","comments":true,"path":"2017/04/24/Silent-Remote-Notification/","link":"","permalink":"https://devchao.com/2017/04/24/Silent-Remote-Notification/","excerpt":"","text":"iOS Silent Remote Notification###官方是这么概述的： 1Silent notifications improve the user experience by helping you keep your app up-to-date, even when it is not running. When apps do not run for extended periods of time, their data can become outdated. When the user finally launches the app again, the outdated data must be replaced, which can cause a delay in using the app. Silent notifications give you a way to wake up your app periodically so that it can refresh its data in the background. 大概意思是说：当app处于前台、后台、甚至不再运行时，静默通知都可以实时更新你的APP，以此来提高用户的体验。当app很长一段时间不再运行时，他的数据就回变旧，此时当用户进入你的app中时，旧的数据需要被替换掉，这会让用户等待，降低了用户体验。怎么解决这个问题呢？静默通知可以解决。静默通知可以定期唤醒你的app,以便与可以在后台刷新数据。 IMPORTANT:静音通知并不意味着可以保持您的应用在后台醒来后一直处于后台，也不用于高优先级更新。 APN将无声通知视为低优先级，并且如果总数变得过多，则可以完全抑制它们的传送。实际的限制是动态的，可以根据条件改变，但尽量不要每小时发送多个通知 发送静默通知需要对通知的有效内容进行特殊配置。如果您payload(后台推送内容)未正确配置，通知可能会显示给用户，而不是在后台传递到您的应用程序。payload配置如下： payload的aps字典必须包含content-available键，并且其值必须为1； payload的aps字典禁止包含alert, sound,活着 badge键 静默通知payload实例 123456789&#123; &quot;aps&quot; : &#123; &quot;content-available&quot; : 1 &#125;, &quot;acme1&quot; : &quot;bar&quot;, &quot;acme2&quot; : 42&#125;``` **正常通知payload实例** { “aps” : { “alert” : { “title” : “Game Request”, “body” : “Bob wants to play poker”, “action-loc-key” : “PLAY” }, “badge” : 5 }, “acme1” : “bar”, “acme2” : [ “bang”, “whiz” ]} 或： { “aps” : { “alert” : “You got your emails.”, “badge” : 9, “sound” : “bingbong.aiff” }, “acme1” : “bar”, “acme2” : 42} ``` 当静默通知被传送给app后，iOS会在后台唤醒你的app，并给出30秒时间去运行，在iOS系统中，系统将会通过app代理调用application:didReceiveRemoteNotification:fetchCompletionHandler:来传送静默通知，使用该方法启动获取新数据所需的一些下载操作。在后台处理远程通知需要您向应用程序添加适当的后台模式。 ####将应用配置为在后台处理无提示通知 1.在Project Navigator中选中你的项目。 2.在editor中选中你的target。 3.选中Capabilities。 4.打开Background Modes开关。 5.勾选Remote notifications复选框。 技术交流群:494826724","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"Apache服务配置","slug":"Apache服务配置","date":"2017-04-15T02:04:35.000Z","updated":"2017-04-15T04:09:08.000Z","comments":true,"path":"2017/04/15/Apache服务配置/","link":"","permalink":"https://devchao.com/2017/04/15/Apache服务配置/","excerpt":"","text":"Mac OS Apache 服务配置Apache 所在位置:/etc/apache2 Apache 配置文件所在位置:/etc/apache2/httpd.conf ###apache下部署web资源 跟windows不一样，它的部署包不是放在htdocs(windows下的存放目录),而是放在 “/资源库/WebServer/Documents/”下面,我们的静态资源就可以丢到这个目录.这个目录是apache的默认目录，有时候为了方便操作，可能需要指向特定的文件夹，该如何修改apache的配置呢？ ###修改默认部署路径 找到Apache配置文件中的DocumentRoot,将其配置目录改为制定路径即可。 1DocumentRoot /Library/WebServer/Documents ###修改apache默认端口找到Apache配置文件中Listen,更改为想要的端口即可。 ###启动停用apache 启用apache的命令：sudo apachectl start/restart 在浏览器中输入localhost或者127.0.0.1即可看到“It works!”的提示。那么，apache就启动成功了！ 停止apache的命令：sudo apachectl stop apache的用法还有非常多，比如 转发配置、ssl配置、日志配置，以后慢慢补充～ 技术交流群:494826724","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://devchao.com/tags/Linux/"}]},{"title":"内敛函数","slug":"内敛函数","date":"2017-04-10T09:52:18.000Z","updated":"2017-04-10T09:59:34.000Z","comments":true,"path":"2017/04/10/内敛函数/","link":"","permalink":"https://devchao.com/2017/04/10/内敛函数/","excerpt":"","text":"内联函数inline参考资料 http://www.jianshu.com/p/d557b0831c6a http://www.blogfshare.com/ioss-static-inline.html http://www.blogfshare.com/ioss-static-inline.html 例： 123456static inline UIBarButtonItem *UIBarButtonWithFixedWidth(CGFloat with)&#123; UIBarButtonItem *button = [[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil]; button.width = with; return button;&#125; 概述： 内联函数是一种小型函数，是以空间换效率的函数，功能较简单，他能够替代宏，static inline通常用于修饰函数或者方法，用于解决函数调用的效率问题： 函数调用是内存地址之间通过call的方式调用,当函数调用完毕之后还会返回原来函数执行的地址,函数调用有时间开销, 汇编时会出现 call 指令.调用call指令就是就需要： (1)将下一条指令的所在地址入栈 (2)并将子程序的起始地址送入PC（于是CPU的下一条指令就会转去执行子程序） 以inline的方式编译的会，会把该函数的code拷贝到每次调用该函数的地方。而static会让生成的二进制文件中没有清晰的符号表，让逆向的人很难弄清楚逻辑。 inline 的优点： 相比函数 inline函数避免了普通函数的,在汇编时必须调用call的缺点:取消了函数的参数压栈，减少了调用的开销,提高效率.所以执行速度确比一般函数的执行速度要快. 集成了宏的优点,使用时直接用代码替换(像宏一样); 以inline的方式编译的会，会把该函数的code拷贝到每次调用该函数的地方。而static会让生成的二进制文件中没有清晰的符号表，让逆向的人很难弄清楚逻辑。 相比宏 避免了宏的缺点:需要预编译.因为inline内联函数也是函数,不需要预编译. 编译器在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确。然后进行一系列的相关检查，就像对待任何一个真正的函数一样。这样就消除了它的隐患和局限性。 可以使用所在类的保护成员及私有成员 使用内敛函数注意事项： 内联函数只是我们向编译器提供的申请,编译器不一定采取inline形式调用函数. 内联函数不能承载大量的代码.如果内联函数的函数体过大,编译器会自动放弃内联. 内联函数内不允许使用循环语句或开关语句. 内联函数的定义须在调用之前. 技术交流群:494826724","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"MAC SSH 服务","slug":"MAC-SSH-服务","date":"2017-03-28T06:23:23.000Z","updated":"2017-03-28T06:23:57.000Z","comments":true,"path":"2017/03/28/MAC-SSH-服务/","link":"","permalink":"https://devchao.com/2017/03/28/MAC-SSH-服务/","excerpt":"","text":"MAC SSH 服务SSH（Secure Shell）是一种通用的、功能强大的、基于软件的网络安全解决方案。计算机每次向网络发送数据时，SSH都会自动对其进行加密。运行 OS X 又或者是 macOS 的较新 Mac 设备都会默认预装 SSH，不过 SSH 守护进程是默认禁用的。 配置 Mac Terminal是自带SSH的，可以用whereis来看看： $ whereis ssh 但是在现有进程中找不到ssh对应的进程： $ ps aux | grep ssh yachaocn 9043 0.0 0.0 2434840 764 s001 R+ 3:52下午 0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=.cvs --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn ssh 直接用ssh命令连接本地主机或远程主机时会遇到下列错误提示： ssh: connect to host localhost port 22: Connection refused 解决办法: 在系统偏好设置》共享》勾选‘远程登陆’或者 终端键入如下命令: 查看SSH服务状态 $ sudo systemsetup -getremotelogin 快速开启 SSH 服务器并允许 SSH 连接进入当前 Mac $ sudo systemsetup -setremotelogin on 输入指令后并没有任何确认信息表明远程登录和 SSH 已经开启，但你可以使用上文提到的方法来检查是否开启成功。 通过终端指令关闭Mac的SSH,并阻止远程连接 $ sudo systemsetup -setremotelogin off 使用 ssh链接远程电脑 ssh username@192.168.100.100 username ： 登录的主机的用户名 192.168.100.100 ：要登录的主机的IP地址 scp远程copy文件 scp .zshrc username@192.168.100.100:/Users/username/ 将当前路径下的.zshrc文件复制到远程主机的/Users/username目录下。 具体用法参见cp和scp用法 技术交流群:494826724","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://devchao.com/tags/Linux/"}]},{"title":"毛玻璃效果的实现","slug":"毛玻璃效果的实现","date":"2017-03-23T09:36:03.000Z","updated":"2017-03-23T09:36:35.000Z","comments":true,"path":"2017/03/23/毛玻璃效果的实现/","link":"","permalink":"https://devchao.com/2017/03/23/毛玻璃效果的实现/","excerpt":"","text":"####制作毛玻璃效果 1.加入属性 1@property (nonatomic, strong) UIVisualEffectView *visualEfView; 2.添加图片 12UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, self.view.bounds.size.width, self.view.bounds.size.height)]; [imageView setImage:[UIImage imageNamed:@&quot;1.jpg&quot;]]; 3.添加毛玻璃效果 123456self.visualEfView = [[UIVisualEffectView alloc] initWithEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleLight]]; _visualEfView.frame = CGRectMake(0, 0, self.view.bounds.size.width, self.view.bounds.size.height/2); _visualEfView.alpha = 0.9; [imageView addSubview:_visualEfView]; [self.view addSubview:imageView]; 运行试一下吧 技术交流群:494826724","categories":[],"tags":[]},{"title":"Linux cp和scp命令","slug":"Linux-cp和scp命令","date":"2017-03-23T09:31:58.000Z","updated":"2017-03-23T09:32:27.000Z","comments":true,"path":"2017/03/23/Linux-cp和scp命令/","link":"","permalink":"https://devchao.com/2017/03/23/Linux-cp和scp命令/","excerpt":"","text":"Linux cp和scp命令Linux为我们提供了两个用于文件copy的命令，一个是cp，一个是scp，但是他们略有不同: cp — 主要是用于在同一台电脑上，在不同的目录之间来回copy文件 scp — 主要是在不同的Linux系统之间来回copy文件 ##cp 详细见 $ man 1 cp cp [OPTIONS] SOURCE DEST — 从源路径copy文件到目的路径 cp [OPTIONS] SOURCE… DIRECTORY — 将多个源文件copy到指定的目录（多个源文件用空格分隔 OPTIONS： -a same as -dpR 尽可能将源文件状态、权限等资料都照原装予以复制，并且是递归copy； -r 表示递归copy，若source中含有目录名，则将目录下之档案亦皆依序拷贝至目的地； -f 表示force，若目的地已经有相同档名的档案存在，则在复制前先予以删除再行复制； 123456范例： 1. 将档案 aaa 复制(已存在)，并命名为 bbb： cp aaa bbb 2. 将所有的C语言程式拷贝至 Finished 子目录中： cp *.c Finished/ ##scpscp是有Security的文件copy，基于ssh登录。操作起来比较方便，比如要把当前一个文件copy到远程另外一台主机上，可以如下命令： $scp /home/daisy/full.tar.gz root@172.19.2.75:/home/root 命令基本格式： scp [OPTIONS] file_source file_target 从本地复制到远程 $ scp local_file remote_username@remote_ip:remote_folder $ scp local_file remote_ip:remote_file 从远程复制到本地 scp root@www.cumt.edu.cn:/home/root/others/music /home/space/music/1.mp3 scp -r www.cumt.edu.cn:/home/root/others/ /home/space/music/ 复制目录: OPTIONS 填入 -r即可 完整格式：scp [本地用户名]@[IP地址]:[文件名1] [远程用户名]@[IP地址]:[文件名2] 本地用户名@IP地址:可以不输入,可能需要输入远程用户名所对应的密码. [OPTIONS] -v 和大多数 linux 命令中的 -v 意思一样 , 用来显示进度 . 可以用来查看连接 , 认证 , 或是配置错误 . -C 使能压缩选项 . -P 选择端口 . 注意 -p 已经被 rcp 使用 . -4 强行使用 IPV4 地址 . -6 强行使用 IPV6 地址 . 注意两点： 1.如果远程服务器防火墙有特殊限制，scp便要走特殊端口，具体用什么端口视情况而定，命令格式如下： #scp -p 4588 remote@www.abc.com:/usr/local/sin.sh /home/administrator 2.使用scp要注意所使用的用户是否具有可读取远程服务器相应文件的权限。 技术交流群:494826724","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://devchao.com/tags/Linux/"}]},{"title":"duoshuo","slug":"duoshuo","date":"2017-03-23T06:43:04.000Z","updated":"2017-03-23T06:46:35.000Z","comments":true,"path":"2017/03/23/duoshuo/","link":"","permalink":"https://devchao.com/2017/03/23/duoshuo/","excerpt":"","text":"‘多说’评论界的老大，一路走好，不舍。2017-3-21","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://devchao.com/tags/随笔/"}]},{"title":"ColorPicker","slug":"ColorPicker","date":"2017-03-23T06:27:32.000Z","updated":"2017-03-23T06:53:29.000Z","comments":true,"path":"2017/03/23/ColorPicker/","link":"","permalink":"https://devchao.com/2017/03/23/ColorPicker/","excerpt":"","text":"ColorPicker ##核心代码详解 ###取视图中某点的颜色 1234567891011121314151617181920212223242526272829303132333435363738- (UIColor *) getColorOfPoint:(CGPoint)point InView:(UIView*)view&#123; unsigned char pixel[4] = &#123;0&#125;; CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); CGContextRef context = CGBitmapContextCreate(pixel, 1, 1, 8, 4, colorSpace, (CGBitmapInfo)kCGImageAlphaPremultipliedLast); CGContextTranslateCTM(context, -point.x, -point.y); [view.layer renderInContext:context]; CGContextRelease(context); CGColorSpaceRelease(colorSpace); NSString *hexColor = [NSString stringWithFormat:@&quot;#%02x%02x%02x&quot;,pixel[0],pixel[1],pixel[2]]; UIColor *color = [self getColorInformationWith:hexColor]; return color;&#125;- (UIColor *)getColorInformationWith:(NSString*)hexColor&#123; //转换hex值 unsigned int red ,green,blue; NSScanner *scanner = [NSScanner scannerWithString:[hexColor substringWithRange:NSMakeRange(1, 2)]]; [scanner scanHexInt:&amp;red]; scanner = [NSScanner scannerWithString:[hexColor substringWithRange:NSMakeRange(3, 2)]]; [scanner scanHexInt:&amp;green]; scanner = [NSScanner scannerWithString:[hexColor substringWithRange:NSMakeRange(5, 2)]]; [scanner scanHexInt:&amp;blue]; return [UIColor colorWithRed:red/255.0 green:green/255.0 blue:blue/255.0 alpha:1];&#125; ###实现UISlider渐变效果 1.设置UISlider的MinimumTrackTintColor和MaximumTrackTintColor为[UIColor clearColor]。 12[self.brightnessSlider setMinimumTrackTintColor:[UIColor clearColor]]; [self.brightnessSlider setMaximumTrackTintColor:[UIColor clearColor]]; 2.设置UISlider的MaximumTrackImage为渐变的图片 3.设置UISlider的MinimumTrackImage为透明的图片 4.设置一个背景ImageView放在Slider的父视图上，位置大小和Slider的一样。并设置image为MaximumTrackImage的图片。 设置图片 1234567891011-(void)changeSliderViewStyleWithColor:(UIColor *)color&#123; //创建渐变图片 UIImage *GradientImage = [self createGradientImageWithSize:CGSizeMake(self.brightnessSlider.bounds.size.width, 10) startColor:color endColor:[UIColor colorWithRed:0 green:0 blue:0 alpha:1] cornerRadius:5.0f]; UIImage *clearImage = [self createImageWithSize:CGSizeMake(self.brightnessSlider.bounds.size.width, 10) Color:[UIColor clearColor] cornerRadius:10.0f]; [self.brightnessSlider setMaximumTrackImage:GradientImage forState:UIControlStateNormal]; [self.brightnessSlider setMinimumTrackImage:clearImage forState:UIControlStateNormal]; self.brightnessSliderBackView.image = GradientImage;&#125; 创建渐变颜色的图片方法 123456789101112131415161718192021222324252627282930313233- (UIImage *)createGradientImageWithSize:(CGSize)size startColor:(UIColor *)startColor endColor:(UIColor *)endColor cornerRadius:(CGFloat)radius&#123; CGFloat height = size.height; CGFloat with = size.width; CGFloat startR = 0,startG = 0, startB = 0, startA = 0; BOOL startResult = [startColor getRed:&amp;startR green:&amp;startG blue:&amp;startB alpha:&amp;startA]; if (!startResult) return nil; CGFloat endR = 0 , endG = 0, endB = 0, endA = 0; BOOL endResult = [endColor getRed:&amp;endR green:&amp;endG blue:&amp;endB alpha:&amp;endA]; if (!endResult) return nil; //创建透明｜2倍图像(清晰，针对视网膜屏幕)上下文 UIGraphicsBeginImageContextWithOptions(CGSizeMake(with, height), NO, 2); CGContextRef context = UIGraphicsGetCurrentContext(); //设置圆角 [[UIBezierPath bezierPathWithRoundedRect:CGRectMake(0, 0, with, height) cornerRadius:radius] addClip]; CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); const CGFloat components[] = &#123; startR, startG, startB, startA, endR, endG, endB, endA, &#125;; const CGFloat locations[] = &#123;0,1&#125;; CGGradientRef gradientRf = CGGradientCreateWithColorComponents(colorSpace, components, locations, 2); CGPoint startPoint = CGPointMake(0, height/2); CGPoint endPoint = CGPointMake(with, height/2); CGContextDrawLinearGradient(context, gradientRf, startPoint, endPoint, kCGGradientDrawsBeforeStartLocation); UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); CGColorSpaceRelease(colorSpace); CGContextRelease(context); return image;&#125; 创建单一颜色的图片 1234567891011121314- (UIImage *)createImageWithSize:(CGSize)size Color:(UIColor *)color cornerRadius:(CGFloat)radius&#123; UIGraphicsBeginImageContextWithOptions(size, NO, 2); CGContextRef context = UIGraphicsGetCurrentContext(); UIBezierPath *bezierPath = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(0, 0, size.width, size.height) cornerRadius:radius]; [bezierPath addClip]; CGContextAddPath(context, bezierPath.CGPath); CGContextSetFillColorWithColor(context, color.CGColor); CGContextFillPath(context); UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); CGContextRelease(context); return image;&#125; 点击下载代码 技术交流群:494826724","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"git操作","slug":"git操作","date":"2017-03-23T03:18:12.000Z","updated":"2017-03-23T03:21:37.000Z","comments":true,"path":"2017/03/23/git操作/","link":"","permalink":"https://devchao.com/2017/03/23/git操作/","excerpt":"","text":"Git操作 - By 亚超基本操作 初始化仓库 git init 配置作者信息 git config –global user.email “youremail@corp.com” git config –global user.name “yourname” 添加文件到暂存区 git add \\ git add * (添加所有文件到暂存区) 移除文件 git rm \\ 重命名一个文件 git mv \\ \\ 提交暂存区 git commit只会提交暂存区（staged）里面的文件 git commit -m “message” 查看工作目录的状态 git status 查看提交历史记录 git log 查看文件改变 git diff ##撤销操作 撤销加入暂存区的操作 git reset HEAD \\ 撤销修改的操作 git checkout – \\ 将本地的修改放进回收站 git stash 从回收站中恢复本地的修改 git stash apply Tag操作 查看tag git tag 创建tag git tag -a v1.0 -m “my version 1.0” 显示tag信息 git show v1.0 对之前的提交打tag git tag -a v0.1 -m “version 0.1” 分支操作 查看分支 git branch 创建分支 git branch \\ 删除分支 git branch -d \\ 切换分支 git checkout \\ 合并分支 git merge \\ rebase操作 git rebase \\ \\ 远端仓库操作 克隆一个远端仓库 git clone URL 添加远端仓库 git remote add \\ \\ 更新远端仓库的分支和数据 git fetch \\ 获取并合并远端仓库的分支到当前分支 git pull \\ \\ eg: git pull origin master 上传本地分支和数据到远端仓库 git push \\ \\ eg: git push origin master 跟踪远端仓库上的分支 git checkout –track origin/testbranch git checkout -b test origin/testbranch 技术交流群:494826724","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://devchao.com/tags/Git/"}]},{"title":"init和initialize区别","slug":"init和initialize区别","date":"2017-03-16T08:09:27.000Z","updated":"2017-03-23T06:58:34.000Z","comments":true,"path":"2017/03/16/init和initialize区别/","link":"","permalink":"https://devchao.com/2017/03/16/init和initialize区别/","excerpt":"","text":"Objective-C中 init initialize与load区别init和initialize init是“-”开头的方法 initialize是“+”开头的类方法 init在类实例化（new）的时候就会调用一次：[ClassName new]相当于[[class alloc]init],我们对init应该是很熟悉的，大多数时候我们不使用new来实例化，而是直接定义自己的init方法通过[[ClassName alloc]initWithXXX]这样来做。 initialize在向类发送消息的时候调用一次：什么是发送消息？实例化一个对象[ClassName new]是发送消息，调用一个类方法[ClassName method]也是向这个类发送消息。 在new的时候，initialize方法会在init之前先调用 只要new一次，init就会调用一次，new多少次，init就调用多少次，但initialize只会调用一次。 如果子类没有实现initialize的重写，在子类收到消息的时候，会调用两次initialize,一次是父类调用的，一次是子类调用的 + (void)load + (void)load 会在类或者类的分类添加到 Objective-c runtime 时调用，该调用发生在 application:willFinishLaunchingWithOptions: 调用之前调用。 父类的 +load 方法先于子类的 +load 方法调用，类本身的 +load 方法调用先于分类的 +load 方法调用。 技术交流群:494826724","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"installApp.md","slug":"installApp-md","date":"2017-03-11T12:36:43.000Z","updated":"2017-03-11T12:36:57.000Z","comments":true,"path":"2017/03/11/installApp-md/","link":"","permalink":"https://devchao.com/2017/03/11/installApp-md/","excerpt":"","text":"Install App 技术交流群:494826724","categories":[],"tags":[]},{"title":"BackgroundFetch","slug":"BackgroundFetch","date":"2017-01-20T04:48:10.000Z","updated":"2017-01-20T04:50:21.000Z","comments":true,"path":"2017/01/20/BackgroundFetch/","link":"","permalink":"https://devchao.com/2017/01/20/BackgroundFetch/","excerpt":"","text":"Background Fetch ###开启Background Fetch 1.在XCode-&gt;TARGETS-&gt;Capabilities-&gt;Background Modes打开并添加Background Fetch.2.在- (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions方法中加入： 1[[UIApplication sharedApplication] setMinimumBackgroundFetchInterval:UIApplicationBackgroundFetchIntervalMinimum]; MinimumBackgroundFetchInterval参数值是两次Fetch时间间隔，不能保证每隔这个时间间隔都会调用。这里设置为UIApplicationBackgroundFetchIntervalMinimum，意思是尽可能频繁的调用我们的Fetch方法。 ###调用Fetch方法1.每次系统Fetch时都会调用如下方法，我们可以在该方法中做刷新数据等操作，操作执行完成以后需要要调用completionHandlerblock()例如：completionHandler(UIBackgroundFetchResultNewData),此回调会告诉系统可以挂起你的APP，并且系统会预估Fetch的耗电情况， 1-(void)application:(UIApplication *)application performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler&#123;&#125;; completionHandler有三个参数: UIBackgroundFetchResultNewData 成功拉取数据 UIBackgroundFetchResultNoData 没有新数据 UIBackgroundFetchResultFailed 拉取数据失败或者超时 代码如下： 1234567891011121314151617-(void)application:(UIApplication *)application performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler&#123; // Call or write any code necessary to get new data, process it and update the UI. // The logic for informing iOS about the fetch results in plain language: if (/** NEW DATA EXISTS AND WAS SUCCESSFULLY PROCESSED **/) &#123; completionHandler(UIBackgroundFetchResultNewData); &#125; if (/** NO NEW DATA EXISTS **/) &#123; completionHandler(UIBackgroundFetchResultNewData); &#125; if (/** ANY ERROR OCCURS **/) &#123; completionHandler(UIBackgroundFetchResultFailed); &#125;&#125; 2.如果应用程式能够快速下载少量内容，并准确反映出他们有内容下载的时间，就会比需要长时间下载内容的APP更可能收到执行时间，所以尽可能地缩短你的任务执行时间。 ###调试BackGround fetch 1.Debug &gt; Simulate Background Fetch. 2.debug模式下，选中Product &gt; Scheme &gt; Edit Scheme ，打开Options,勾选Launch due to a background fetch event. command＋R运行。 技术交流群:494826724","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"关于应用程序启动到后台","slug":"关于应用程序启动到后台","date":"2016-12-27T09:30:20.000Z","updated":"2016-12-27T09:30:49.000Z","comments":true,"path":"2016/12/27/关于应用程序启动到后台/","link":"","permalink":"https://devchao.com/2016/12/27/关于应用程序启动到后台/","excerpt":"","text":"关于应用程序启动到后台支持后台执行的应用程序可以由系统重新启动以处理传入事件。如果应用程序因用户强制退出之外的任何原因而终止，则系统在以下事件之一发生时启动应用程序: 对于定位的APP: 系统接收到符合应用程序配置的传递标准的位置更新。(The system receives a location update that meets the app’s configured criteria for delivery.) 设备进入或退出注册区域。 （地区可以是地理区域或iBeacon地区。）(The device entered or exited a registered region. (Regions can be geographic regions or iBeacon regions.)) 对于音频的APP:音频框架需要应用程序处理一些数据。 （音频应用包括播放音频或使用麦克风的应用）。(For audio apps, the audio framework needs the app to process some data. (Audio apps include those that play audio or use the microphone.)) 对于蓝牙的app： 以中心角色扮演的应用程序从连接的外围设备接收数据。(An app acting in the central role receives data from a connected peripheral.) 在外围角色中扮演的应用程序从连接的中心接收命令。(在外围角色中扮演的应用程序从连接的中心接收命令。) 对于后台下载的app: 应用程序的推送通知到达，通知的有效内容包含键为content-available值为1的字段。(A push notification arrives for an app and the payload of the notification contains the content-available key with a value of 1.) 系统在机会性时刻唤醒应用程序，开始下载新内容。(The system wakes the app at opportunistic moments to begin downloading new content.) 对于使用NSURLSession类在后台下载内容的应用程序，与该会话对象关联的所有任务都已成功完成或接收到错误。(For apps downloading content in the background using the NSURLSession class, all tasks associated with that session object either completed successfully or received an error.) 在大多数情况下，系统不会在用户强制退出后重新启动应用程序。一个例外是位置应用程序(在iOS 8和更高版本中，在用户强制退出后重新启动。),但在其他情况下，用户必须明确地启动应用程序或重新启动设备，然后应用程序才能由系统自动启动到后台。当设备上启用密码保护时，系统不会在用户首次解锁设备之前在后台启动应用程序。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"安装cocoapods遇到curl 56 SSLRead()","slug":"安装cocoapods遇到curl 56 SSLRead()","date":"2016-12-13T06:49:53.000Z","updated":"2016-12-13T06:52:31.000Z","comments":true,"path":"2016/12/13/安装cocoapods遇到curl 56 SSLRead()/","link":"","permalink":"https://devchao.com/2016/12/13/安装cocoapods遇到curl 56 SSLRead()/","excerpt":"","text":"安装cocoapods遇到error: RPC failed; curl 56 SSLRead() return error -36问题 在安装cocoapods遇到的问题 1234567 [!] /usr/bin/git clone https://github.com/gali8/Tesseract-OCR-iOS.git /var/folders/56/4ktty6b14t55wh8_lttpztnr0000gn/T/d20161121-12186-hcqt0c --template= --single-branch --depth 1 --branch 4.0.0Cloning into &apos;/var/folders/56/4ktty6b14t55wh8_lttpztnr0000gn/T/d20161121-12186-hcqt0c&apos;...error: RPC failed; curl 56 SSLRead() return error -36fatal: The remote end hung up unexpectedlyfatal: early EOFfatal: index-pack failed 解决方案 打开终端输入以下命令： 1sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer 参考自http://blog.csdn.net/wm9028/article/details/51840759","categories":[],"tags":[{"name":"cocopods","slug":"cocopods","permalink":"https://devchao.com/tags/cocopods/"}]},{"title":"iOS开启GPS精准定位","slug":"iOS开启GPS精准定位","date":"2016-12-02T01:57:29.000Z","updated":"2016-12-02T01:57:55.000Z","comments":true,"path":"2016/12/02/iOS开启GPS精准定位/","link":"","permalink":"https://devchao.com/2016/12/02/iOS开启GPS精准定位/","excerpt":"","text":"开启GPS精准定位 精准定位 1.在Info-plist中加入UIRequiredDeviceCapabilities键，此键是数组类型 UIRequiredDeviceCapabilities(lets iTunes and the App Store know which device-related features an app requires in order to run) 2.在数组中加入gps关键字 官方解释： Include this key if your app requires (or specifically prohibits) the presence of GPS (or AGPS) hardware when tracking locations. (You should include this key only if you need the higher accuracy offered by GPS hardware.) If you include this key, you should also include the location-services key. You should require GPS only if your app needs location data more accurate than the cellular or Wi-fi radios might otherwise provide. 中文描述：(个人水平有限,如有错误，敬请指正，感激) 如果你的app需要GPS或者AGPS硬件去获取位置信息时，需要加入此键。（如果你需要FPS或者AGPS硬件获得非常精准的位置信息时，需要加入此键），注意：加入此键时，也需要加入location-services字段，如果加入了gps和location-services两个字段，那么你的app将只能通过GPS进行定位，当然这比蜂窝移动网络、Wi-fi广播等其他提供的位置服务要精准的多。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"关于CoreLocation定位的方向问题","slug":"关于CoreLocation定位的方向问题","date":"2016-12-02T01:54:45.000Z","updated":"2016-12-02T01:55:58.000Z","comments":true,"path":"2016/12/02/关于CoreLocation定位的方向问题/","link":"","permalink":"https://devchao.com/2016/12/02/关于CoreLocation定位的方向问题/","excerpt":"","text":"关于CoreLocation定位的方向问题Core Location支持两种不同的获取方向相关信息的方式： 当设备处于某个点时，带有磁力计的设备能能够报告其位置信息；此类被称为设备的朝向。 当设备处于移动过程中时，通过带有GPS硬件的报告的位置位置信息；此类被称为设备的行动方向。 朝向和行动方向表现出设备不同的信息。设备的朝向真实的反映出了设备在一个点时相对于磁北或者真北的朝向。而设备的行动方向则表现了设备在运动过程中的运动方向其并没有考虑设备的方向。你使用一种还是这两种相结合，完全取决于你的APP；例如：一个导航APP是否要在两者之间切换完全取决于用户的速度，在步行速度时，设备的朝向对于在当前环境下的确认用户方向是用户最为关心的事情；而在一辆车里运动时，行动方向则变得尤为重要。 如果你的app用到了位置相关信息时，为了更好的运行，在Info.plist中加入UIRequiredDeviceCapabilities键，这个键是一个包涵字符串的数组，这个数组描述了你的app具有哪些服务特征。app store使用这些信息对app进行归类，更好的为用户服务。如：用户没有GPS功能，就会选择不包含GPS功能的app去下载。 UIRequiredDeviceCapabilities中和方向相关的字符串有两个： magnetometer 包涵这个字符串时，app会获得设备的朝向 gps 包涵这个字符串时，app会获得设备的行动方向。 PS：加入gps时，也要加入location-services字符串。两者都需要时，再加入location-services字段 总结： 当只需要GPS或者AGPS加入location-services和gps字段。 不需要GPS或者AGPS时，加入location-services和magnetometer. 需要两种时,加入location-services和magnetometer和gps；或者只加入location-services（默认是两种都用）","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"数据模型排序.md","slug":"数据模型排序-md","date":"2016-11-21T01:53:35.000Z","updated":"2016-11-21T01:53:57.000Z","comments":true,"path":"2016/11/21/数据模型排序-md/","link":"","permalink":"https://devchao.com/2016/11/21/数据模型排序-md/","excerpt":"","text":"数据模型排序前提：有一个装满Model的数组 self.dataSourceArray 排序代码： 123456789NSArray *array = [self.dataSourceArray sortedArrayUsingComparator:^NSComparisonResult(id _Nonnull obj1, id _Nonnull obj2) &#123; //给对象排序 NSComparisonResult result = [obj1 compareParkInfo:obj2]; return result; &#125;]; // 排序好的 for (ParkInfo *info in array) &#123; NSLog(@&quot;%ld&quot;, (long)info.feePredict); &#125; 实现代码： 12// Model.h- (NSComparisonResult)compareParkInfo:(ParkInfo *)parkinfo; 12345678910// 在Model.m// 自定义排序方法- (NSComparisonResult)compareParkInfo:(ParkInfo *)parkinfo&#123; // 升序 NSComparisonResult result = [[NSNumber numberWithInteger:self.feePredict] compare:[NSNumber numberWithInteger:parkinfo.feePredict]]; if (result == NSOrderedSame) &#123; // 可以按照其他属性进行排序 &#125; return result;&#125; 技术交流：494826724","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"addChildViewController属性介绍","slug":"addChildViewController属性介绍","date":"2016-09-23T08:16:47.000Z","updated":"2017-05-05T02:41:35.000Z","comments":true,"path":"2016/09/23/addChildViewController属性介绍/","link":"","permalink":"https://devchao.com/2016/09/23/addChildViewController属性介绍/","excerpt":"","text":"addChildViewController属性介绍) 在iOS5中，ViewController中，苹果API添加了addChildViewController方法，希望我们在使用addSubview时，同时调用[self addChildViewController:child]方法将sub view对应的viewController也加到当前ViewController的管理中。 对于那些当前暂时不需要显示的subview,需要显示时再调用transitionFromViewController方法。将其添加进入底层的ViewController中。 优点： 1.无疑，对页面中的逻辑更加分明了。相应的View对应相应的ViewController。 2.当某个子View没有显示时，将不会被Load，减少了内存的使用。 3.当内存紧张时，没有Load的View将被首先释放，优化了程序的内存释放机制。 4.一些控制器不被调用的方法如：-(void)viewWillAppear;将会被调用。 创建两个切换的控制器: 12345 first=[[FirstViewController alloc]initWithNibName:@&quot;FirstViewController&quot;bundle:nil]; second=[[SecondViewController alloc]initWithNibName:@&quot;SecondViewController&quot;bundle:nil]; //启动后先添加first，大儿子 [self addChildViewController:first];[self.view addSubview:first.view]; first切换到second: 12345678910111213- (void)dealWithFirstClick&#123; //调用addChildViewController之前会自动调用second的willMoveToParentViewController [self addChildViewController:second]; [self transitionFromViewController:first toViewController:second duration:0.5 options:UIViewAnimationOptionTransitionCrossDissolve animations:nil completion:^(BOOL finished)&#123;// addChildViewController之后手动添加的didMoveToParentViewController [second didMoveToParentViewController:self]; //删除之前first之前手动添加的willMoveToParentViewController [first willMoveToParentViewController:nil]; //调用removeFromParentViewController之后会自动调用first的didMoveToParentViewController [first removeFromParentViewController]; &#125;]; &#125; second 切换到first: 12345678- (void)dealWithSecondClick&#123; [self addChildViewController:first]; [self transitionFromViewController:second toViewController:first duration:0.5 options:UIViewAnimationOptionTransitionFlipFromRight animations:nil completion:^(BOOL finished)&#123; [first didMoveToParentViewController:self]; [second willMoveToParentViewController:nil]; [second removeFromParentViewController]; &#125;];&#125; 参考https://www.objc.io/issues/1-view-controllers/containment-view-controller/ https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/CreatingCustomContainerViewControllers/CreatingCustomContainerViewControllers.html","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"获取崩溃日志","slug":"获取崩溃日志","date":"2016-09-22T06:07:57.000Z","updated":"2016-09-22T06:08:25.000Z","comments":true,"path":"2016/09/22/获取崩溃日志/","link":"","permalink":"https://devchao.com/2016/09/22/获取崩溃日志/","excerpt":"","text":"获取崩溃日志实现原理： 主要借助产生异常时捕获异常的回调，在NSException的头文件中有如下定义： FOUNDATION_EXPORT void NSSetUncaughtExceptionHandler(NSUncaughtExceptionHandler * __nullable);步骤：1.在程序启动时赋予异常回调地址： 1NSSetUncaughtExceptionHandler (&amp;UncaughtExceptionHandler); 2.实现异常回调函数 12345678910 void UncaughtExceptionHandler(NSException *exception) &#123; NSArray *arr = [exception callStackSymbols];//得到当前调用栈信息 NSString *reason = [exception reason];//非常重要，就是崩溃的原因 NSString *name = [exception name];//异常类型 NSLog(@&quot;exception type : %@ \\n crash reason : %@ \\n call stack info : %@&quot;, name, reason, arr);// NSThread *currentThread = [NSThread currentThread]; NSArray *symbolsArray = [NSThread callStackSymbols]; NSLog(@&quot;%@&quot;,symbolsArray);&#125; 测试 1.测试代码 123NSArray *array = @[@&quot;2&quot;,@&quot;1&quot;]; NSString *str = array[3]; NSLog(@&quot;%@&quot;,str); 2.控制台打印： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849502016-09-06 10:47:14.828 ViewControllerDemo[876:317539] exception type : NSRangeException crash reason : *** -[__NSArrayI objectAtIndex:]: index 3 beyond bounds [0 .. 1] call stack info : ( 0 CoreFoundation 0x0000000182666dc8 &lt;redacted&gt; + 148 1 libobjc.A.dylib 0x0000000181ccbf80 objc_exception_throw + 56 2 CoreFoundation 0x0000000182547098 CFRunLoopRemoveTimer + 0 3 ViewControllerDemo 0x0000000100071804 __29-[ViewController viewDidLoad]_block_invoke + 156 4 libdispatch.dylib 0x00000001000c5a7c _dispatch_call_block_and_release + 24 5 libdispatch.dylib 0x00000001000c5a3c _dispatch_client_callout + 16 6 libdispatch.dylib 0x00000001000d1cc8 _dispatch_after_timer_callback + 148 7 libdispatch.dylib 0x00000001000c5a3c _dispatch_client_callout + 16 8 libdispatch.dylib 0x00000001000ddde0 _dispatch_source_latch_and_call + 2848 9 libdispatch.dylib 0x00000001000c7fe0 _dispatch_source_invoke + 808 10 libdispatch.dylib 0x00000001000caec0 _dispatch_main_queue_callback_4CF + 524 11 CoreFoundation 0x000000018261cd50 &lt;redacted&gt; + 12 12 CoreFoundation 0x000000018261abb8 &lt;redacted&gt; + 1628 13 CoreFoundation 0x0000000182544c50 CFRunLoopRunSpecific + 384 14 GraphicsServices 0x0000000183e2c088 GSEventRunModal + 180 15 UIKit 0x000000018782a088 UIApplicationMain + 204 16 ViewControllerDemo 0x00000001000722c8 main + 124 17 libdyld.dylib 0x00000001820e28b8 &lt;redacted&gt; + 4)2016-09-06 10:47:14.830 ViewControllerDemo[876:317539] ( 0 ViewControllerDemo 0x0000000100071eec UncaughtExceptionHandler + 220 1 CoreFoundation 0x0000000182667138 &lt;redacted&gt; + 652 2 libobjc.A.dylib 0x0000000181ccc23c &lt;redacted&gt; + 112 3 libc++abi.dylib 0x0000000181cbef44 &lt;redacted&gt; + 16 4 libc++abi.dylib 0x0000000181cbe85c &lt;redacted&gt; + 0 5 libobjc.A.dylib 0x0000000181ccc094 &lt;redacted&gt; + 0 6 CoreFoundation 0x0000000182547098 CFRunLoopRemoveTimer + 0 7 ViewControllerDemo 0x0000000100071804 __29-[ViewController viewDidLoad]_block_invoke + 156 8 libdispatch.dylib 0x00000001000c5a7c _dispatch_call_block_and_release + 24 9 libdispatch.dylib 0x00000001000c5a3c _dispatch_client_callout + 16 10 libdispatch.dylib 0x00000001000d1cc8 _dispatch_after_timer_callback + 148 11 libdispatch.dylib 0x00000001000c5a3c _dispatch_client_callout + 16 12 libdispatch.dylib 0x00000001000ddde0 _dispatch_source_latch_and_call + 2848 13 libdispatch.dylib 0x00000001000c7fe0 _dispatch_source_invoke + 808 14 libdispatch.dylib 0x00000001000caec0 _dispatch_main_queue_callback_4CF + 524 15 CoreFoundation 0x000000018261cd50 &lt;redacted&gt; + 12 16 CoreFoundation 0x000000018261abb8 &lt;redacted&gt; + 1628 17 CoreFoundation 0x0000000182544c50 CFRunLoopRunSpecific + 384 18 GraphicsServices 0x0000000183e2c088 GSEventRunModal + 180 19 UIKit 0x000000018782a088 UIApplicationMain + 204 20 ViewControllerDemo 0x00000001000722c8 main + 124 21 libdyld.dylib 0x00000001820e28b8 &lt;redacted&gt; + 4)2016-09-06 10:47:14.830 ViewControllerDemo[876:317539] *** Terminating app due to uncaught exception &apos;NSRangeException&apos;, reason: &apos;*** -[__NSArrayI objectAtIndex:]: index 3 beyond bounds [0 .. 1]&apos;*** First throw call stack:(0x182666db0 0x181ccbf80 0x182547098 0x100071804 0x1000c5a7c 0x1000c5a3c 0x1000d1cc8 0x1000c5a3c 0x1000ddde0 0x1000c7fe0 0x1000caec0 0x18261cd50 0x18261abb8 0x182544c50 0x183e2c088 0x18782a088 0x1000722c8 0x1820e28b8)libc++abi.dylib: terminating with uncaught exception of type NSException","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"NSTimer内存释放问题","slug":"NSTimer内存释放问题","date":"2016-09-01T07:52:08.000Z","updated":"2016-09-18T08:30:11.000Z","comments":true,"path":"2016/09/01/NSTimer内存释放问题/","link":"","permalink":"https://devchao.com/2016/09/01/NSTimer内存释放问题/","excerpt":"","text":"NSTimer 内存释放问题当我们在某个对象中使用定时器时，如果在对象释放前没有对定时器合理的释放（从runloop中移除），你将发现，即使你将对象置为nil，该对象也不会被释放，原因是定时器的RunLoop中仍然持有该对象。 那么如何合理的释放定时器呢？ PS.在对象释放前，调用 [timer invalidate]，如下： 12345if (timer.isValid) &#123; [timer invalidate]; &#125; timer=nil; [self dismissViewControllerAnimated:YES completion:nil]; 如果你直接调用[self dismissViewControllerAnimated:YES completion:nil]，那么模态呈现的控制器并不会被释放掉.. 技术交流群:494826724","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"仿苹果安装软件进度条","slug":"仿苹果安装软件进度条","date":"2016-08-10T07:25:27.000Z","updated":"2017-05-20T05:16:13.000Z","comments":true,"path":"2016/08/10/仿苹果安装软件进度条/","link":"","permalink":"https://devchao.com/2016/08/10/仿苹果安装软件进度条/","excerpt":"","text":"苹果安装软件进度条特点分析： 由黑色半透明视图覆盖。 中间有个完全透明的圆环。 中间进度由圆饼状图形构成，且当前已完成进度为完全透明，未完成进度为黑色半透明。 完成后完全透明视图向外扩散。 暂停后出现暂停图标，继续时回复原状。 暂停和继续均有扩散动画。(跟4动画相似) 技术实现分析：为实现半透明视图覆盖＋自定义完全透明区域，考虑用Quartz 2D绘制图像实现。 1. command + N 新建类CircleProgressView 继承自UIControl(考虑到要添加相应事件)，定义常量。 1234567891011121314#define YCColorMaker(r, g, b, a) [UIColor colorWithRed:((r)/255) green:((g)/255) blue:((b)/255) alpha:(a)]#import &lt;Foundation/Foundation.h&gt;#import &quot;CircleProgressView.h&quot;@interface CircleProgressView ()@property(nonatomic) BOOL beginCompletedAnimation;@property(nonatomic) CGFloat margin;//两个圆半径差@property(nonatomic) CGFloat R1;//大圆半径@property(nonatomic) CGFloat R2;//小圆半径@property(nonatomic)CGFloat pauseR;//暂停时添加的小圆半径@property(nonatomic) CGFloat MaxR;//进度完成后最大的扩散半径,（斜对角线的一半）//扩散动画的定时器@property(nonatomic,strong) CADisplayLink *timer;@end 2.添加初始化方法，初始化常量 12345678910111213141516171819202122232425-(instancetype)initWithFrame:(CGRect)frame&#123; if (self = [super initWithFrame:frame]) &#123; self.backgroundColor = [UIColor clearColor]; _pauseR = 18; self.progress = 0.0001; _margin = 4.0f; _R2 = 25; _R1 = _R2 + _margin; CGFloat width = frame.size.width; CGFloat height = frame.size.height; CGFloat MaxR = sqrt(pow(width, 2) + pow(height, 2)); _MaxR = MaxR; self.userInteractionEnabled = YES; [self addTarget:self action:@selector(clickedProgressView:) forControlEvents:UIControlEventTouchUpInside]; self.selected = NO; self.layer.shouldRasterize = YES; self.layer.rasterizationScale = [UIScreen mainScreen].scale; &#125; return self;&#125; 3. 暂停事件 123456789101112131415//点击暂停－开始-(void)clickedProgressView:(UIControl *)control&#123; if (!self.delegate) &#123; return; &#125; self.selected = !control.selected; if (self.selected) &#123; [self.delegate pause:self.progress]; &#125;else&#123; [self.delegate active:self.progress]; &#125; [self setNeedsDisplay]; &#125; 4. 进度条set方法 1234567891011121314151617//Progress set modth-(void)setProgress:(CGFloat)progress&#123; if (_progress != progress) &#123; _progress = MIN(1.0, fabs(progress)); [self setNeedsDisplay]; &#125;// 开始扩散动画 if (_progress == 1.0) &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [self performAnimation]; &#125;); &#125;&#125; 5. 启动定时器，绘制扩散动画 1234567891011121314151617181920212223242526272829//启动定时器，绘制扩散动画。-(void)performAnimation&#123; if (_R1 &gt; _MaxR) &#123; return; &#125; _timer = [CADisplayLink displayLinkWithTarget:self selector:@selector(animate:)]; [_timer addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode]; [_timer addToRunLoop:[NSRunLoop mainRunLoop] forMode:UITrackingRunLoopMode]; /* PS NSDefaultRunLoopMode - 标准优先级 NSRunLoopCommonModes - 高优先级 UITrackingRunLoopMode - 用于UIScrollView和别的控件的动画 在我们的例子中，我们是用了NSDefaultRunLoopMode，但是不能保证动画平滑的运行，所以就可以用NSRunLoopCommonModes来替代。但是要小心，因为如果动画在一个高帧率情况下运行，你会发现一些别的类似于定时器的任务或者类似于滑动的其他iOS动画会暂停，直到动画结束。 同样可以同时对CADisplayLink指定多个run loop模式，于是我们可以同时加入NSDefaultRunLoopMode和UITrackingRunLoopMode来保证它不会被滑动打断，也不会被其他UIKit控件动画影响性能 */&#125;-(void)animate:(NSTimer *)sender&#123; if (_R1 &lt;= _MaxR) &#123; [self setNeedsDisplay]; &#125;else&#123; [_timer invalidate]; _timer =nil; &#125;&#125; 6. 重写-(void)drawRect:(CGRect)rect，开始绘制。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253-(void)drawRect:(CGRect)rect&#123;// 得到视图的宽度 CGFloat width = rect.size.width;// 得到视图的高度 CGFloat height = rect.size.height;// 计算圆心 CGFloat centerX = width/2; CGFloat centerY = height/2;// 得到绘图上下文 CGContextRef context = UIGraphicsGetCurrentContext();// 设置颜色 CGContextSetRGBFillColor(context, 0, 0, 0, 0.5); // 绘制矩形 CGContextMoveToPoint(context, 0, 0); CGContextAddRect(context, rect);// 绘制大圆 CGContextMoveToPoint(context, centerX, centerY); if (self.progress &lt; 1.0) &#123; CGContextAddArc(context, centerX, centerY, _R1, -M_PI_2, -M_PI_2 + M_PI*2, 0); &#125;else&#123; _R1 +=1; CGContextAddArc(context, centerX, centerY, _R1, -M_PI_2, -M_PI_2 + M_PI*2, 0); &#125;// 绘制小圆 CGContextMoveToPoint(context, centerX, centerY);// 参数一：绘图上下文；参数二：绘图圆心；参数三：起始角度；参数四，结束角度；参数五：绘制方向（1:顺时针，0:逆时针） CGContextAddArc(context, centerX, centerY, _R2, -M_PI_2, -M_PI_2 + M_PI*2*self.progress, 1); //暂停 if (self.isSelected) &#123; CGContextMoveToPoint(context, centerX, centerY); CGContextAddArc(context, centerX, centerY, _pauseR, -M_PI_2 +self.progress *M_PI*2, -M_PI_2, 1);// 暂停开始点1 CGFloat pasueX1 = centerX - _pauseR/4 - 2; CGFloat pasueY1 = centerY - _pauseR/4; CGRect pasueFrame1 = CGRectMake(pasueX1, pasueY1, 4, 12);// 暂停开始点2 CGFloat pasueX2 = centerX + _pauseR/4 - 2; CGFloat pasueY2 = pasueY1; CGRect pasueFrame2 = CGRectMake(pasueX2, pasueY2, 4, 12); CGContextMoveToPoint(context, pasueX1 , pasueY1); CGContextAddRect(context, pasueFrame1); CGContextMoveToPoint(context, pasueX2, pasueY2); CGContextAddRect(context, pasueFrame2); &#125;// 填充样式：奇偶填充（默认为非零绕束规则填充，） CGContextEOFillPath(context);&#125; 代码地址：https://github.com/yachaocn/apple-install-app-progress 技术交流群:494826724","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"OC常用技巧","slug":"OC常用技巧","date":"2016-07-28T09:40:33.000Z","updated":"2016-09-18T08:30:27.000Z","comments":true,"path":"2016/07/28/OC常用技巧/","link":"","permalink":"https://devchao.com/2016/07/28/OC常用技巧/","excerpt":"","text":"OC常用技巧1.clang warning 1234#pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Wgnu&quot; //code #pragma clang diagnostic pop 表示在这个区间里忽略一些特定的clang的编译警告，因为AFNetworking作为一个库被其他项目引用，所以不能全局忽略clang的一些警告，只能在有需要的时候局部这样做，作者喜欢用?:符号，所以经常见忽略-Wgnu警告的写法.详见这里 2.dispatch_once 12345678static dispatch_queue_t url_request_operation_completion_queue() &#123; static dispatch_queue_t af_url_request_operation_completion_queue; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; af_url_request_operation_completion_queue = dispatch_queue_create(&quot;com.alamofire.networking.operation.queue&quot;, DISPATCH_QUEUE_CONCURRENT ); &#125;); return af_url_request_operation_completion_queue; &#125; 为保证线程安全，所有单例都用dispatch_once生成，保证只执行一次，这也是iOS开发常用的技巧。 3.weak &amp; strong self 常看到一个 block 要使用 self，会处理成在外部声明一个 weak 变量指向 self，在 block 里又声明一个 strong 变量指向 weakSelf： 1234__weak __typeof(self)weakSelf = self; self.backgroundTaskIdentifier = [application beginBackgroundTaskWithExpirationHandler:^&#123; __strong __typeof(weakSelf)strongSelf = weakSelf; &#125;]; weakSelf是为了block不持有self，避免循环引用，而再声明一个strongSelf是因为一旦进入block执行，就不允许self在这个执行过程中释放。block执行完后这个strongSelf会自动释放，没有循环引用问题。 技术交流群:494826724","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"图片处理之图片着色","slug":"图片处理之图片着色","date":"2016-07-28T08:54:32.000Z","updated":"2016-09-18T08:30:20.000Z","comments":true,"path":"2016/07/28/图片处理之图片着色/","link":"","permalink":"https://devchao.com/2016/07/28/图片处理之图片着色/","excerpt":"","text":"图像效果1.亮图像效果2.特亮图像效果3.黑暗图像效果4.给图片上色 实现： 新建UIImage类别ImageEffects代码如下：UIImage+ImageEffects.h 12345678910111213@import UIKit;@interface UIImage (ImageEffects)- (UIImage *)applyLightEffect;- (UIImage *)applyExtraLightEffect;- (UIImage *)applyDarkEffect;- (UIImage *)applyTintEffectWithColor:(UIColor *)tintColor;- (UIImage *)applyBlurWithRadius:(CGFloat)blurRadius tintColor:(UIColor *)tintColor saturationDeltaFactor:(CGFloat)saturationDeltaFactor maskImage:(UIImage *)maskImage;@end UIImage+ImageEffects.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#import &quot;UIImage+ImageEffects.h&quot;@import Accelerate;#import &lt;float.h&gt;@implementation UIImage (ImageEffects)- (UIImage *)applyLightEffect&#123; UIColor *tintColor = [UIColor colorWithWhite:1.0 alpha:0.3]; return [self applyBlurWithRadius:30 tintColor:tintColor saturationDeltaFactor:2.8 maskImage:nil];&#125;- (UIImage *)applyExtraLightEffect&#123; UIColor *tintColor = [UIColor colorWithWhite:0.97 alpha:0.82]; return [self applyBlurWithRadius:20 tintColor:tintColor saturationDeltaFactor:1.8 maskImage:nil];&#125;- (UIImage *)applyDarkEffect&#123; UIColor *tintColor = [UIColor colorWithWhite:0.11 alpha:0.73]; return [self applyBlurWithRadius:20 tintColor:tintColor saturationDeltaFactor:1.8 maskImage:nil];&#125;- (UIImage *)applyTintEffectWithColor:(UIColor *)tintColor&#123; const CGFloat EffectColorAlpha = 0.6; UIColor *effectColor = tintColor; int componentCount = CGColorGetNumberOfComponents(tintColor.CGColor); if (componentCount == 2) &#123; CGFloat b; if ([tintColor getWhite:&amp;b alpha:NULL]) &#123; effectColor = [UIColor colorWithWhite:b alpha:EffectColorAlpha]; &#125; &#125; else &#123; CGFloat r, g, b; if ([tintColor getRed:&amp;r green:&amp;g blue:&amp;b alpha:NULL]) &#123; effectColor = [UIColor colorWithRed:r green:g blue:b alpha:EffectColorAlpha]; &#125; &#125; return [self applyBlurWithRadius:10 tintColor:effectColor saturationDeltaFactor:-1.0 maskImage:nil];&#125;- (UIImage *)applyBlurWithRadius:(CGFloat)blurRadius tintColor:(UIColor *)tintColor saturationDeltaFactor:(CGFloat)saturationDeltaFactor maskImage:(UIImage *)maskImage&#123; // Check pre-conditions. if (self.size.width &lt; 1 || self.size.height &lt; 1) &#123; NSLog (@&quot;*** error: invalid size: (%.2f x %.2f). Both dimensions must be &gt;= 1: %@&quot;, self.size.width, self.size.height, self); return nil; &#125; if (!self.CGImage) &#123; NSLog (@&quot;*** error: image must be backed by a CGImage: %@&quot;, self); return nil; &#125; if (maskImage &amp;&amp; !maskImage.CGImage) &#123; NSLog (@&quot;*** error: maskImage must be backed by a CGImage: %@&quot;, maskImage); return nil; &#125; CGRect imageRect = &#123; CGPointZero, self.size &#125;; UIImage *effectImage = self; BOOL hasBlur = blurRadius &gt; __FLT_EPSILON__; BOOL hasSaturationChange = fabs(saturationDeltaFactor - 1.) &gt; __FLT_EPSILON__; if (hasBlur || hasSaturationChange) &#123; UIGraphicsBeginImageContextWithOptions(self.size, NO, [[UIScreen mainScreen] scale]); CGContextRef effectInContext = UIGraphicsGetCurrentContext(); CGContextScaleCTM(effectInContext, 1.0, -1.0); CGContextTranslateCTM(effectInContext, 0, -self.size.height); CGContextDrawImage(effectInContext, imageRect, self.CGImage); vImage_Buffer effectInBuffer; effectInBuffer.data = CGBitmapContextGetData(effectInContext); effectInBuffer.width = CGBitmapContextGetWidth(effectInContext); effectInBuffer.height = CGBitmapContextGetHeight(effectInContext); effectInBuffer.rowBytes = CGBitmapContextGetBytesPerRow(effectInContext); UIGraphicsBeginImageContextWithOptions(self.size, NO, [[UIScreen mainScreen] scale]); CGContextRef effectOutContext = UIGraphicsGetCurrentContext(); vImage_Buffer effectOutBuffer; effectOutBuffer.data = CGBitmapContextGetData(effectOutContext); effectOutBuffer.width = CGBitmapContextGetWidth(effectOutContext); effectOutBuffer.height = CGBitmapContextGetHeight(effectOutContext); effectOutBuffer.rowBytes = CGBitmapContextGetBytesPerRow(effectOutContext); if (hasBlur) &#123; // A description of how to compute the box kernel width from the Gaussian // radius (aka standard deviation) appears in the SVG spec: // http://www.w3.org/TR/SVG/filters.html#feGaussianBlurElement // // For larger values of &apos;s&apos; (s &gt;= 2.0), an approximation can be used: Three // successive box-blurs build a piece-wise quadratic convolution kernel, which // approximates the Gaussian kernel to within roughly 3%. // // let d = floor(s * 3*sqrt(2*pi)/4 + 0.5) // // ... if d is odd, use three box-blurs of size &apos;d&apos;, centered on the output pixel. // CGFloat inputRadius = blurRadius * [[UIScreen mainScreen] scale]; NSUInteger radius = floor(inputRadius * 3. * sqrt(2 * M_PI) / 4 + 0.5); if (radius % 2 != 1) &#123; radius += 1; // force radius to be odd so that the three box-blur methodology works. &#125; vImageBoxConvolve_ARGB8888(&amp;effectInBuffer, &amp;effectOutBuffer, NULL, 0, 0, radius, radius, 0, kvImageEdgeExtend); vImageBoxConvolve_ARGB8888(&amp;effectOutBuffer, &amp;effectInBuffer, NULL, 0, 0, radius, radius, 0, kvImageEdgeExtend); vImageBoxConvolve_ARGB8888(&amp;effectInBuffer, &amp;effectOutBuffer, NULL, 0, 0, radius, radius, 0, kvImageEdgeExtend); &#125; BOOL effectImageBuffersAreSwapped = NO; if (hasSaturationChange) &#123; CGFloat s = saturationDeltaFactor; CGFloat floatingPointSaturationMatrix[] = &#123; 0.0722 + 0.9278 * s, 0.0722 - 0.0722 * s, 0.0722 - 0.0722 * s, 0, 0.7152 - 0.7152 * s, 0.7152 + 0.2848 * s, 0.7152 - 0.7152 * s, 0, 0.2126 - 0.2126 * s, 0.2126 - 0.2126 * s, 0.2126 + 0.7873 * s, 0, 0, 0, 0, 1, &#125;; const int32_t divisor = 256; NSUInteger matrixSize = sizeof(floatingPointSaturationMatrix)/sizeof(floatingPointSaturationMatrix[0]); int16_t saturationMatrix[matrixSize]; for (NSUInteger i = 0; i &lt; matrixSize; ++i) &#123; saturationMatrix[i] = (int16_t)roundf(floatingPointSaturationMatrix[i] * divisor); &#125; if (hasBlur) &#123; vImageMatrixMultiply_ARGB8888(&amp;effectOutBuffer, &amp;effectInBuffer, saturationMatrix, divisor, NULL, NULL, kvImageNoFlags); effectImageBuffersAreSwapped = YES; &#125; else &#123; vImageMatrixMultiply_ARGB8888(&amp;effectInBuffer, &amp;effectOutBuffer, saturationMatrix, divisor, NULL, NULL, kvImageNoFlags); &#125; &#125; if (!effectImageBuffersAreSwapped) effectImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); if (effectImageBuffersAreSwapped) effectImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); &#125; // Set up output context. UIGraphicsBeginImageContextWithOptions(self.size, NO, [[UIScreen mainScreen] scale]); CGContextRef outputContext = UIGraphicsGetCurrentContext(); CGContextScaleCTM(outputContext, 1.0, -1.0); CGContextTranslateCTM(outputContext, 0, -self.size.height); // Draw base image. CGContextDrawImage(outputContext, imageRect, self.CGImage); // Draw effect image. if (hasBlur) &#123; CGContextSaveGState(outputContext); if (maskImage) &#123; CGContextClipToMask(outputContext, imageRect, maskImage.CGImage); &#125; CGContextDrawImage(outputContext, imageRect, effectImage.CGImage); CGContextRestoreGState(outputContext); &#125; // Add in color tint. if (tintColor) &#123; CGContextSaveGState(outputContext); CGContextSetFillColorWithColor(outputContext, tintColor.CGColor); CGContextFillRect(outputContext, imageRect); CGContextRestoreGState(outputContext); &#125; // Output image is ready. UIImage *outputImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return outputImage;&#125; 技术交流群:494826724","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"生活","slug":"生活","date":"2016-05-13T02:58:29.000Z","updated":"2016-05-13T03:00:26.000Z","comments":true,"path":"2016/05/13/生活/","link":"","permalink":"https://devchao.com/2016/05/13/生活/","excerpt":"","text":"幸福是每一个微小的生活愿望的达成，当你想吃的时候有的吃，想被爱的时候有人来爱你。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://devchao.com/tags/随笔/"}]},{"title":"上善若水，人淡如菊！","slug":"上善若水，人淡如菊！","date":"2016-04-15T01:14:09.000Z","updated":"2016-04-15T01:14:56.000Z","comments":true,"path":"2016/04/15/上善若水，人淡如菊！/","link":"","permalink":"https://devchao.com/2016/04/15/上善若水，人淡如菊！/","excerpt":"","text":"上善若水，人淡如菊!","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://devchao.com/tags/随笔/"}]},{"title":"APP Extensions","slug":"APP Extensions","date":"2016-04-14T06:47:51.000Z","updated":"2016-09-18T08:30:41.000Z","comments":true,"path":"2016/04/14/APP Extensions/","link":"","permalink":"https://devchao.com/2016/04/14/APP Extensions/","excerpt":"","text":"App Extensions 前言： extension是iOS8新开放的一种对几个固定系统区域的扩展机制，它可以在一定程度上弥补iOS的沙盒机制对应用间通信的限制。 extension的出现，为用户提供了在其它应用中使用我们应用提供的服务的便捷方式，比如用户可以在Today的widgets中查看应用展示的简略信息，而不用再进到我们的应用中，这将是一种全新的用户体验；但是，extension的出现可能会减少用户启动应用的次数，同时还会增大开发者的工作量。 几个关键字 extension point 系统中支持extension的区域，extension的类别也是据此区分的，iOS上共有Today、Share、Action、Photo Editing、Storage Provider、Custom keyboard几种，其中Today中的extension又被称为widget。 每种extension point的使用方式和适合干的活都不一样，因此不存在通用的extension。 app extension 即为本文所说的extension。extension并不是一个独立的app，它有一个包含在app bundle中的独立bundle，extension的bundle后缀名是.appex。其生命周期也和普通app不同，这些后文将会详述。 extension不能单独存在，必须有一个包含它的containing app。 另外，extension需要用户手动激活，不同的extension激活方式也不同，比如： 比如Today中的widget需要在Today中激活和关闭；Custom keyboard需要在设置中进行相关设置；Photo Editing需要在使用照片时在照片管理器中激活或关闭；Storage Provider可以在选择文件时出现；Share和Action可以在任何应用里被激活，但前提是开发者需要设置Activation Rules，以确定extension需要在合适出现。 containing app 尽管苹果开放了extension，但是在iOS中extension并不能单独存在，要想提交到AppStore，必须将extension包含在一个app中提交，并且app的实现部分不能为空,这个包含extension的app就叫containing app。 extension会随着containing app的安装而安装，同时随着containing app的卸载而卸载。 host app 能够调起extension的app被称为host app，比如widget的host app就是Today。 extension和containing app、host app之间的关系 extension和host app extension和host app之间可以通过extensionContext属性直接通信，该属性是新增加的UIViewController类别： 123456@interface UIViewController(NSExtensionAdditions) &lt;NSExtensionRequestHandling&gt; // Returns the extension context. Also acts as a convenience method for a view controller to check if it participating in an extension request. @property (nonatomic,readonly,retain) NSExtensionContext *extensionContext NS_AVAILABLE_IOS(8_0); @end 实际上extension和host app之间是通过IPC（interprocess communication）实现的，只是苹果把调用接口高度抽象了，我们并不需要关注那么底层的东西。 containing app和host app 他们之间没有任何直接关系，也从来不需要通信。 extension和containing app 这二者之间的关系最复杂，纠纠缠缠扯不清关系。 尽管extension的bundle是放在containing app的bundle中，但是他们是两个完全独立的进程，之间不能直接通信,不过extension可以通过openURL的方式启动containing app（当然也能启动其它app），不过必须通过extensionContext借助host app来实现： 12345678//通过openURL的方式启动Containing APP - (void)openURLContainingAPP &#123; [self.extensionContext openURL:[NSURL URLWithString:@&quot;appextension://123&quot;] completionHandler:^(BOOL success) &#123; NSLog(@&quot;open url result:%d&quot;,success); &#125;]; &#125; extension中是无法直接使用openURL的。 可以共享Shared resources extension和containing app可以共同读写一个被称为Shared resources的存储区域，这是通过App Groups实现的。两者的关系如图： containing app能够控制extension的出现和隐藏 1234567891011//让隐藏的插件重新显示 - (void)showTodayExtension &#123; [[NCWidgetController widgetController] setHasContent:YES forWidgetWithBundleIdentifier:@&quot;com.wangzz.app.extension&quot;]; &#125; //隐藏插件 - (void)hiddeTodayExtension &#123; [[NCWidgetController widgetController] setHasContent:NO forWidgetWithBundleIdentifier:@&quot;com.wangzz.app.extension&quot;]; &#125; App Groups这是iOS8新开放的功能，在OS X上早就可用了。它主要用于同一group下的app共享同一份读写空间，以实现数据共享。 在app中开启 App Groups位于： 1TARGETS--&gt;AppExtensionDemo--&gt;Capabilities--&gt;App Groups 找到以后，将App Groups右上角的开关打开，然后选择添加groups，比如我的是group.com.sisniswift.WhirlyGlobe. 在extension中开启 我创建的是widget，target名称为TodayExtension，对应的App Groups位于： 1TARGETS--&gt;TodayExtension--&gt;Capabilities--&gt;App Groups 开启方式和app中一样，需要注意的是必须保证这里地App Groups名称和app中的相同，即为group.com.sisniswift.WhirlyGlobe. extension和containing app数据共享App Groups给我们提供了同一group内app可以共同读写的区域，可以通过以下方式实现数据共享 通过NSUserDefaults共享数据 存数据 通过以下方式向NSUserDefaults中保存数据 123456- (void)saveTextByNSUserDefaults &#123; NSUserDefaults *shared = [[NSUserDefaults alloc] initWithSuiteName:@&quot;group.com.sisniswift.WhirlyGlobe&quot;]; [shared setObject:_textField.text forKey:@&quot;saveData&quot;]; [shared synchronize]; &#125; 需要注意的是： 保存数据的时候必须指明group id 而且要注意NSUserDefaults能够处理的数据只能是可plist化的对象，详情见Property List Programming Guide。 为了防止出现数据同步问题，不要忘记调用[shared synchronize]; 读数据 1234567- (NSString *)readDataFromNSUserDefaults &#123; NSUserDefaults *shared = [[NSUserDefaults alloc] initWithSuiteName:@&quot;group.com.sisniswift.WhirlyGlobe&quot;]; NSString *value = [shared valueForKey:@&quot;wangzz&quot;]; return value; &#125; 通过NSFileManager共享数据 NSFileManager在iOS7提供了containerURLForSecurityApplicationGroupIdentifier方法，可以用来实现app group共享数据。 保存数据 123456789101112131415- (BOOL)saveTextByNSFileManager &#123; NSError *err = nil; NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@&quot;group.com.sisniswift.WhirlyGlobe&quot;]; containerURL = [containerURL URLByAppendingPathComponent:@&quot;Library/Caches/good&quot;]; NSString *value = _textField.text; BOOL result = [value writeToURL:containerURL atomically:YES encoding:NSUTF8StringEncoding error:&amp;err]; if (!result) &#123; NSLog(@&quot;%@&quot;,err); &#125; else &#123; NSLog(@&quot;save value:%@ success.&quot;,value); &#125; return result; 读数据 12345678NSString *)readTextByNSFileManager &#123; NSError *err = nil; NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@&quot;group.com.sisniswift.WhirlyGlobe&quot;]; containerURL = [containerURL URLByAppendingPathComponent:@&quot;Library/Caches/good&quot;]; NSString *value = [NSString stringWithContentsOfURL:containerURL encoding:NSUTF8StringEncoding error:&amp;err]; return value; 数据同步 两个应用共同读取同一份数据，就会引发数据同步问题。WWDC2014的视频中建议使用NSFileCoordination实现普通文件的读写同步，而数据库可以使用CoreData,Sqlite也支持同步 extension和containing app代码共享通过embedded framework 实现带码的共享，我们先建立一个动态库，然后将共用的代码放在这个动态库里，然后在extension和它的containing app的target中连接动态库，这样就能实现代码的共享。 关于动态库的制作,连接，使用，请参见The dynamic library plug-in 生命周期extension和普通app的最大区别之一是生命周期。 开始 在用户通过host app点击extension时，系统就会实例化extension应用，这是生命周期的开始。 执行任务 在extension启动以后，开始执行它的使命。 终止 在用户取消任务，或者任务执行结束，或者开启了一个长时后台任务时，系统会将其杀掉。 由此可见，extension就是为了任务而生！ 官方描述如下图： 技术交流群:494826724","categories":[],"tags":[]},{"title":"APP之间数据的共享","slug":"APP之间数据的共享","date":"2016-04-14T06:46:49.000Z","updated":"2017-05-18T14:56:02.000Z","comments":true,"path":"2016/04/14/APP之间数据的共享/","link":"","permalink":"https://devchao.com/2016/04/14/APP之间数据的共享/","excerpt":"","text":"iOS APP之间数据的共享iOS APP之间数据的共享在这里我把他分为两大块： 1.app之间数据的互传 2.app共用一套数据 I.app之间数据的互传1.通过app内嵌Air drop功能实现 AirDrop主要通过注册应用程序可支持的文件类型，实现两台设备的两个app之间数据的共享。 注册应用程序可支持的文件类型参见：http://yachaocn.com/2015/08/26/app%E6%B3%A8%E5%86%8C%E9%BB%98%E8%AE%A4%E6%89%93%E5%BC%80%E7%B1%BB%E5%9E%8B/ UIActivityViewController用法详见http://www.cocoachina.com/industry/20140425/8233.html 1234567891011NSString *string = ...; NSURL *URL = ...; UIActivityViewController *activityViewController = [[UIActivityViewController alloc] initWithActivityItems:@[string, URL] applicationActivities:nil]; [navigationController presentViewController:activityViewController animated:YES completion:^&#123; // ... &#125;]; 2.通过蓝牙实现app之间的数据的共享与交互详细参见http://yachaocn.com/2016/04/12/BLE%204.0%20%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89core%20bluetooth%20%E6%A6%82%E8%BF%B0/ 3.即时通讯 有许多方法实现这里我只给出自己亲身用过的技术基于xmpp通信协议的即时通信技术 sockets等不再列举 II.App共用一套数据1.UIPasteboard 剪贴板是应用程序之间传递数据的简单方式，建议不要使用全局的粘贴板，而是自己根据名字创建一个新的粘贴板，防止其它地方全局拷贝的影响。然后把需要共享的内容复制到粘贴板，粘贴板的内容可以是文本、URL、图片和UIColor等，另一个app就可以根据粘贴板的名字去读取相关的信息。 写 12UIPasteboard *pasteboard = [UIPasteboard pasteboardWithName:@&quot;myPasteboard&quot; create:YES];pasteboard.string = @&quot;myShareData&quot;; 读 12UIPasteboard *pasteboard = [UIPasteboard pasteboardWithName:@&quot;myPasteboard&quot; create:NO]; NSString *content = pasteboard.string; 2.Custom URL Scheme URL Scheme能够让我们通过自定义的协议在应用程序间传递信息，当你想要发送数据给一个实现了自定义URL Scheme的应用时，只需要创建好合适格式的URL，然后调用openURL:方法，系统就会载入注册了该scheme的应用然后将你的URL传递给他. 12NSURL *myURL = [NSURL URLWithString:@&quot;todolist://newid=20&quot;];[[UIApplication sharedApplication] openURL:myURL]; 当另一个应用被启动时，只需按规则截取相应信息即可。 3.Shared Keychain Access iOS的keychain提供一种安全保存信息的方式，可以保存密码等数据，而且keychain中的数据不会因为你删除app而丢失，你可以在重新安装后继续读取keychain中的数据。通常每个应用程序只允许访问自己在keychain中保存的数据，不过假如你使用同一个证书的话，使用相同的sychain group，不同的app也可以通过keychain来实现应用间的数据共享。 在target》capabilities里开启Shared Keychain Access，选择相同的Shared Keychain group。 使用key chain存储数据用法参见http://yachaocn.com/2016/01/05/%E8%8E%B7%E5%8F%96UUID%E5%B9%B6%E5%AD%98%E5%82%A8%E5%88%B0keychain%E4%B8%AD/ 4.APP Group 1.在dev center添加一个app group：这里我创建了group.com.siniswift.WhirlyGlobe 2.创建一个app，在target》capabilities里开启APP Group，并选择group.com.siniswift.WhirlyGlobe 3.存储数据 方法一：NSUserDefaults 123NSUserDefaults *defaut = [[NSUserDefaults alloc]initWithSuiteName:@&quot;group.com.siniswift.WhirlyGlobe&quot;]; [defaut setObject:@&quot;分享的数据&quot; forKey:@&quot;share&quot;]; [defaut synchronize]; 方法二：NSFileManager 1234567891011121314 -(BOOL)saveTextByNSFileManager &#123; NSError *err = nil; NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@&quot;group.wangzz&quot;]; containerURL = [containerURL URLByAppendingPathComponent:@&quot;Library/Caches/good&quot;]; NSString *value = _textField.text; BOOL result = [value writeToURL:containerURL atomically:YES encoding:NSUTF8StringEncoding error:&amp;err]; if (!result) &#123; NSLog(@&quot;%@&quot;,err); &#125; else &#123; NSLog(@&quot;save value:%@ success.&quot;,value); &#125; return result; 4.另建一个app，重复第2步，然后读去存储的数据： 读取数据一：NSUserDefaults 1NSUserDefaults *defaut = [[NSUserDefaults alloc]initWithSuiteName:@&quot;group.com.siniswift.WhirlyGlobe&quot;];NSString *data = [defaut objectForKey:@&quot;share&quot;]; 读取数据二：NSFileManager 12345678NSString *)readTextByNSFileManager &#123; NSError *err = nil; NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@&quot;group.wangzz&quot;]; containerURL = [containerURL URLByAppendingPathComponent:@&quot;Library/Caches/good&quot;]; NSString *value = [NSString stringWithContentsOfURL:containerURL encoding:NSUTF8StringEncoding error:&amp;err]; return value; 技术交流群:494826724","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"BLE 4.0 技术学习（四）蓝牙后台进程","slug":"BLE 4.0 技术学习（四）蓝牙后台进程","date":"2016-04-13T08:35:21.000Z","updated":"2016-12-16T07:50:31.000Z","comments":true,"path":"2016/04/13/BLE 4.0 技术学习（四）蓝牙后台进程/","link":"","permalink":"https://devchao.com/2016/04/13/BLE 4.0 技术学习（四）蓝牙后台进程/","excerpt":"","text":"BLE 4.0 学习（三）蓝牙后台进程 iOS APP Core Bluetooth 后台进程当你的应用在后台或者被挂起时，通常情况下central和peripheral的Core Bluetooth任务都会被禁用。你可以声明你的app允许蓝牙核心背景执行模式从挂起状态苏醒，然后去执行一些与蓝牙有关的事件。即使您的应用程序并不需要全方位的后台处理支持，当有重要事件发生，它仍然可以要求通过系统提醒。 即使您的应用程序支持一个或两个核心蓝牙后台执行模式，它不能永远运行。在某些时候，系统可能需要终止您的应用程序以释放内存对于当前的前景应用程序，造成任何活动或挂起的连接丢失。 ###只在前台活动的app（指那些没有声明支持蓝牙后台进程的应用） 以下简称只在前台活动的app 大多数app是不支持后台进程的，除非你请求特定的蓝牙后台服务，否则在你应用程序在前台时经历短暂的挂起状态进入到后台时，您的应用程序无法执行蓝牙相关的任务，也不是能处理任何蓝牙相关的事件，直到它恢复到前台。 只在前台活动的app，当其进入挂起状态或者进入后台后，在Central那一侧是无法扫描，发现正在广播的Peripheral的。在Peripheral那一侧，广播也会被禁用，任何Central试图去获取characteristic的值时都会产生一个错误， 基于这些情况，当你的应用程序进入挂起或进入后台，你是不会收到任何的通知的。 解决办法：利用Peripheral的连接时的选项 当只在前台活动的app，当有蓝牙相关事件产生时，系统将会将其放入队列中，然后当其再次进入前台时，将此事件传递给app。 也就是说，当Central产生一些事件时，Core Bluetooth提供了一个警示框去提示用户，用户可以使用这个警示框决定应用是否使该应用重新进入前台！ 你可以在CBCentralManager中的connectPeripheral:options:方法中的options参数中设定这些参数： CBConnectPeripheralOptionNotifyOnConnectionKey：当设备连接状态是成功的时，应用程序突然被挂起，系统将会弹出一个警示框。 CBConnectPeripheralOptionNotifyOnDisconnectionKey:对于给定的Peripheral，如果你想在应用程序挂起造成蓝牙断开连接时，弹出一个断开连接的提示框时，你可以使用此键。 CBConnectPeripheralOptionNotifyOnNotificationKey：对于给定的一个Peripheral，当应用程序进入挂起状态时，如果你想对所有的通知都给出一个提示框，用此键。 ###蓝牙核心后台执行模式 如果你想要你的app在进入后台时执行一些后台的任务，你必须在Info.plist中声明，使你的app支持后台执行模式。当你声明了这些时，当应用进入挂起状态时系统将会唤醒你的app，并允许app去执行与蓝牙相关的事件。 I.配置plist 有两个后台执行模式需要声明：一个是作为Central时，一个是作为Peripheral时，如果你的app两个都声明了，那么你的app就会具有了后台执行蓝牙相关事件的能力。添加UIBackgroundModes键到你的Info.plist，去声明你的app支持后台执行模式，设置这个键为一个数组，包含下面一个或两个字符串。 bluetooth-central :使用Core Bluetooth framework与BLE Peripheral进行交流。 bluetooth-peripheral :使用Core Bluetooth framework分享app数据。如图： PS:iOS 10 后需要在info-plist中添加 NSBluetoothPeripheralUsageDescription 键，该键是string类型，用于申请使用蓝牙时的提示信息，如果没有此键蓝牙功能将不能使用！ 如下： II.Central端后台执行模式 当你的app在Info.plist中的UIBackgroundModes键配置了 bluetooth-central字符时， Core Bluetooth framework允许允许你的应用程序在后台时执行一些蓝牙相关事件操作。当你的app在后台时，你仍然可以搜索并连接到Peripheral，搜索并和Peripheral进行数据交互，此外系统唤醒你的app时，CBCentralManagerDelegate 或者 CBPeripheralDelegate的代理方法都照样被调用，让你的app来处理重要的Central相关事件。例如当建立连接，或断开连接；Peripheral发送更新的characteristic的值时；当Central Manager的状态发生变化时，Central都会调用上述方法。 尽管你的app在后台时能够执行一些蓝牙相关的事件，但是在扫描设备时，app在前台与在后台是不一样的，当你的app在后台扫描设备时： CBCentralManagerScanOptionAllowDuplicatesKey键将会被忽略，多重发现的Peripheral事件，将会被合成一个单一的发现事件。 所有的在后台扫描Peripheral外设的Centarl，搜索到广告包的时间将会增加，也就是Central将会花费很长的时间发现正在广播的Peripheral。 这些变化有助于减少无线电的使用，提升您的iOS设备上的电池寿命。 III.Peripheral端后台执行模式 当执行Peripheral端后台任务时，你必须在Info.plist中UIBackgroundModes键中配置bluetooth-peripheral字符串，当你配置了这些时，系统将会唤醒你的app去执行读，写，订阅事件。 除了允许你的app被唤醒去执行读，写，和从连接的Central收到请求外， Core Bluetooth framework 也允许你的app在后台进行广播，总的来说有如下不同： CBAdvertisementDataLocalNameKey 键将会被忽略并且Peripheral的本地名将不会被广播。 包含在CBAdvertisementDataServiceUUIDsKey广告键值所有服务的UUID被放置在一个特殊的“溢出”区;他们只能通过显式扫描他们的iOS设备才会被发现。 在后台广播的Peripheral的发送广播的频率将会被降低。 ###更好的使用后台模式 虽然声明你的应用程序，使其支持蓝牙核心后台执行模式中的一种或两种可能需要满足特定的用例，你应该始终负责任地执行后台处理。由于执行许多蓝牙相关的任务，需要积极利用iOS设备的机载无线电和，相反，无线电使用对iOS设备的电池产生不利影响，所以尽量减少后台工作量。被唤醒的app需要迅速处理它的相关事件，否则app有可能再此进入挂起状态。 声明对蓝牙核心后台执行模式的支持时，任何应用程序必须遵循几个基本原则： 应用程式应基于会话，并提供一个界面，允许用户决定何时开始和停止蓝牙相关事件的输送。 一旦被唤醒，应用程序有10秒左右时间去完成的任务。理想的情况下，就应该尽可能快完成的任务，并允许自身被再次挂起。那些花太多时间在后台执行的应用程序可能被系统杀掉。 不要唤醒app让其执行一些无关的任务， ###执行长期的后台工作 一些app需要 Core Bluetooth framework执行长期的后台工作，想象一下，你看发了一款家庭安全app，他能用蓝牙和门的锁进行交互，当用户离开家的时候，设备超出了锁的监控范围，和锁的蓝牙的连接就会断掉，然后锁就会自动锁上门，当用户转了一小圈再次回到家时，iOS设备将自动再次连接到锁。 现在想象一下：如果用户离开家几天后，如果当用户离开家的时候，用户将app终止掉（退出），当用户重新回到家时，app将无法与锁自动连接，用户可能无法打开家门，对于这样的app来说，当用户重新回到家时，能够继续使用Core Bluetooth执行长期的后台活动是十分必要的！那么我们如何去解决这种问题呢？请看下面： I.状态的保存与恢复 由于状态的保存和恢复是建立在Core Bluetooth基础上的。你的app可以选择这个功能去要求系统存储app的Central Manager和Peripheral Mnager的状态，并继续代表它们执行一些蓝牙相关任务，甚至是你的app不再运行，当这些任务之一完成之后，系统将会重新启动你的app进入后台，并给你的app一个机会去恢复它的状态并妥善处理这一事件。在上述的家庭安全App的情况下，系统将会监控连接请求，当用户重新回到家中，系统会重新启动app，调用 centralManager:didConnectPeripheral: 代理回调，连接蓝牙。 Core Bluetooth支持Central和Peripheral端的状态的存储与恢复！当你的app添加Central角色并添加了支持状态的保存与恢复后，当系统打算中止你的app并释放内存资源时，系统会存储你的Central Manager对象的状态（如果你的app有多个Central Manager对象时，你可以选择那一个需要系统跟踪存储）。对于给定的CBCentralManager对象，系统将会跟踪它的： Central Manager扫描的服务（和当扫描开始的时候，扫描的参数options，） Central Manager试图或已经连接的Peripherals Central Manager订阅的一些characteristics 对于给定的CBPeripheralManager对象，系统将会跟踪它的： Peripheral正在广播的数据 Peripheral已经发布到设备数据库的服务（services）和特征（characteristics） 已经订阅了Peripheral的特征值的一些Centrals 当你的重新被系统唤醒并进入后台时，你可以重新实例化你的Central和Peripheral 管理对象并存储他们的状态。下一节将详细描述如何在你的app中存储并恢复其状态。 II.添加对状态存储和恢复的支持 在Core Bluetooth中状态的保存与恢复是可选的特征有助于你的app更好的工作。你可以按如下步骤添加对此特性的支持： (必须)在初始化Central Manager和Peripheral Manager是选择状态的存储与恢复。在下面的”选择状态的存储与恢复”小节会提到如何做。 (必须)在你的app被系统重新启动的时候重新实例化这些Central Manager和Peripheral Manager对象。在下面的“重新实例化Central和Peripheral管理对象”小节会提到。 (必须)实现相应的恢复委托方法。在下面的“实现适当的委托方法”小节中提到。 (可选)更新你的Central和Peripheral的管理对象的初始化过程。在下面的“更新你的初始化过程”小节中会提到。 1.选择状态的存储与恢复 当你初始化一个central 或 peripheral manager时，选择状态的存储与恢复需要提供一个唯一的存储标记：identifier. 例如初始化一个CBCentralManager时需要提供CBCentralManagerOptionRestoreIdentifierKey选项 1234myCentralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil options:@&#123; CBCentralManagerOptionRestoreIdentifierKey: @&quot;myCentralManagerIdentifier&quot; &#125;]; PS:应为设备上的app可以有多个CBCentralManager 和 CBPeripheralManager 对象，所以在使用CBCentralManagerOptionRestoreIdentifierKey时提供一个唯一的标示，以至于系统能够区分它们 2.重新实例化Central和Peripheral管理对象 当你的系统重新启动你的app，并进入后台时，要做的第一件事情就是：用它们对应的存储标记重新初始化你的Central和Peripheral Manager对象。如果你的app只有一个Central或者Peripheral管理对象并且这个管理对象存在于你app整个生命周期，那么其它的步骤就不需要做了。 如果你的app中使用了一个或多个Central或Peripheral Manager的对象，或者如果它没有存在于你app整个生命周期，那么，当它被系统重新启动时，你的app需要去知道那些管理者（managers）需要去初始化。通过app代理的application:didFinishLaunchingWithOptions:方法中的(UIApplicationLaunchOptionsBluetoothCentralsKey 和 UIApplicationLaunchOptionsBluetoothPeripheralsKey)键， 你会获得一个当系统退出app时保存的这个管理对象的标记的列表。 例如当你的应用程序被系统重新启动时，你可以检索所有系统为你保存的Central Manager对象的存储标记（identifiers）。如下： 123456- (BOOL)application:(UIApplication *)applicationdidFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; NSArray *centralManagerIdentifiers = launchOptions[UIApplicationLaunchOptionsBluetoothCentralsKey]; ... 在你获得这些标记后，用一个循环重新初始化这些对象。 在应用程序不再运行时，你的应用被系统重新启动，用系统提供的标记初始化的对象，可以执行一些与蓝牙有关的操作 3.实现适当的委托方法 在你的app中重新初始化适当的central 和 peripheral manager 对象后，用Bluetooth系统状态通过同步它们的状态恢复它们，要使你的系统的自身的方法是你的app快速恢复其状态，需要实现适当的恢复代理方法。对于central manager使用 centralManager:willRestoreState: 代理方法，对于peripheral manager使用 peripheralManager:willRestoreState:方法。 PS：对于选择使用Core Bluetooth的存储和恢复特性的app，首先会掉用centralManager:willRestoreState: 和peripheralManager:willRestoreState:，对于那些没有选择使用Core Bluetooth的存储和恢复特性的app， centralManagerDidUpdateState: and peripheralManagerDidUpdateState: 代理方法首先会被调用 在两个代理方法中，最后一个字典参数存储了，当app被退出时存储的管理者的信息，例如centralManagerDidUpdateState: 中的到central manager已经或尝试连接的一些Peripheral。 123456- (void)centralManager:(CBCentralManager *)central willRestoreState:(NSDictionary *)state &#123; NSArray *peripherals = state[CBCentralManagerRestoredStatePeripheralsKey]; ... 对于获得的这些外设我们可以恢复与它的状态！比如用 [myCentralManager connectPeripheral:peripheral options:nil]重新连接外设。 4.更新你的初始化过程 在你实现了上面的三步后，你可能会关注更新你的central 和 peripheral manager的初始化过程。通过这一步可选的步骤，可能会使你的事情顺利进行。例如你的应用程序可能在搜索已连接的外设的数据时被中止，当你的app被中止时，不知道发现（discovery）进程进展到什么地步了，为你又想要确定到底进展到什么地步了。当你的app代理方法centralManagerDidUpdateState: 中初始化时，你会发现你已经成功的搜索到了特定的恢复的Peripheral的Service，如下： 123456789NSUInteger serviceUUIDIndex = [peripheral.services indexOfObjectPassingTest:^BOOL(CBService *obj, NSUInteger index, BOOL *stop) &#123; return [obj.UUID isEqual:myServiceUUIDString]; &#125;]; if (serviceUUIDIndex == NSNotFound) &#123; [peripheral discoverServices:@[myServiceUUIDString]]; ... 正如上面所说，如果系统在你的Central还没完成搜索Peripheral的服务时中止你的app，同时调用 discoverServices:开始探索恢复的Peripheral的数据；如果你的app已经成功发现了设备的服务，你应该检查适当的characteristics是否被发现了，是否成功订阅了它们；以这种方式更新你的初始化过程，你才能够确保能在正确的时间处理正确的事件！ 技术交流群:494826724","categories":[],"tags":[]},{"title":"BLE 4.0 技术学习（三）外设Peripheral","slug":"BLE 4.0 技术学习（三）外设Peripheral","date":"2016-04-12T07:24:03.000Z","updated":"2016-09-18T08:31:11.000Z","comments":true,"path":"2016/04/12/BLE 4.0 技术学习（三）外设Peripheral/","link":"","permalink":"https://devchao.com/2016/04/12/BLE 4.0 技术学习（三）外设Peripheral/","excerpt":"","text":"BLE 4.0 学习（三）外设Peripheral 以Peripheral作为本地端，以Central作为远端。 执行常见的外设角色任务前言：在上一章节中我们学习了如何在Central那侧如何进行蓝牙低耗能进行数据的交互，这一节我们将学习使用Core blueTooth框架实现以Peripheral作为本地端的数据交互。以下我将以简单的代码帮助你开发以Peripherial为本地端与远程Central之间的交互，主要有以下步骤： 启动外围设备管理器对象 在本地周边设置服务和特征 发布您的设备的本地数据De服务和特征 广播你的服务 响应中央（Central）的读写请求 给订阅特征的远程中心（Central）发送更新的特征（Charateristic） ###I.创建Peripher管理对象** 创建CBPeripheralManager对象，第二个参数为nil代表在主线程。 12myPeripheralManager = [[CBPeripheralManager alloc] initWithDelegate:self queue:nil options:nil]; 当你创建了CBPeripheralManager对象后，它的代理方法 peripheralManagerDidUpdateState:将会被掉用，你必须实现这个代理方法以确保BLe是被支持并且可用的。 ###II.设置你的服务和特征 正如下图所示组织你的服务和特征以便于远端Central识别你的服务与特征。 1.用UUID区分不同的服务和特征 周边的服务和特征是由128位的CBUUID代表在蓝牙核心框架对象。你可以使用下面方法创建一个CBUUID对象 12CBUUID *myCustomServiceUUID = [CBUUID UUIDWithString:@&quot;71DA3FD1-7E10-41C1-B16F-4430B506CDE7&quot;]; 2.创建服务和特征树形结构 服务和特征有了CBUUID后，用以下方法创建可变的服务和特征,创建可变的特征如下： 1234myCharacteristic = [[CBMutableCharacteristic alloc] initWithType:myCharacteristicUUID properties:CBCharacteristicPropertyRead value:myValue permissions:CBAttributePermissionsReadable]; 其中的properties和permissions:两个参数，properties代表了characteristic是可读的还是可写的,如果是CBCharacteristicPropertyNotify ｜CBCharacteristicPropertyRead 时表它可以被Central订阅，permissions代表了连接的Central是否可以订阅此characteristic特征值。 PS:如果你的value参数设置了值，这个值将被缓存起来，并且properties和permissions:两个参数必须为只读的，如果你想在characteristic的生命周期中改变value的值，那么value的参数应该设置为nil！ 有了CBMutableCharacteristic之后我们需要创建一个CBMutableService如下： 1myService = [[CBMutableService alloc] initWithType:myServiceUUID primary:YES]; primary:YES参数表明服务是主相对于次的。一个主要的服务描述的装置的主要功能。例如，心脏监测仪的主要服务可以是从显示器的心脏速率传感器暴露心脏速率数据，而次要业务可以是，以暴露传感器的电池的数据。 然后我们需要将CBMutableCharacteristic的对象加到CBMutableService上去： 1myService.characteristics = @[myCharacteristic]; ###发布你的服务和特征 在你创建了服务和特征树形结构后，需要将服务添加到本地的Peripheral上去： 1[myPeripheralManager addService:myService]; 添加后，PeriPherial manager的代理方法peripheralManager:didAddService:error:将会被调用。 12345678- (void)peripheralManager:(CBPeripheralManager *)peripheral didAddService:(CBService *)service error:(NSError *)error &#123; if (error) &#123; NSLog(@&quot;Error publishing service: %@&quot;, [error localizedDescription]); &#125; ... Note: After you publish a service and any of its associated characteristics to the peripheral’s database, the service is cached and you can no longer make changes to it. ###广播你的服务 当你将你的服务和特征发布到设备的服务和特征数据库中后，你需要向监听你的所有远端Central广播你的服务和特征，如下你可以使用CBPeripheralManager 的方法startAdvertising: 12[myPeripheralManager startAdvertising:@&#123; CBAdvertisementDataServiceUUIDsKey : @[myFirstService.UUID, mySecondService.UUID] &#125;]; 后面的字典参数中，CBAdvertisementDataServiceUUIDsKey代表了你想要广播的服务的UUID，在PeripheralManager中只有两个键是有用的： CBAdvertisementDataLocalNameKey and CBAdvertisementDataServiceUUIDsKey. 当你开始在本地Peripheral上广播时，Peripgeral的代理方法peripheralManagerDidStartAdvertising:error:将会被掉用 1234567- (void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral error:(NSError *)error &#123; if (error) &#123; NSLog(@&quot;Error advertising: %@&quot;, [error localizedDescription]); &#125; ... PS:当你的app进入后台时，广播还是有效的，这部分将在下一章节中讨论：关于BLE 4.0 后台进程 ###从Central响应读或者写请求 当你连接到一个或多个远端Central时，你将会从它Central收到读或者写请求，此时你需要以合适的方式响应这些请求！下面的例子说明如何处理这样的请求。 当一个连接的远端Central请求读去一个Charateristic的值时，Peripheral Manager的代理方法peripheralManager:didReceiveReadRequest: 将会被调用，代理方法中将会以一个CBATTRequest对象方式把请求传递给你，其中有一系列的参数，你可以用它来完成请求。 12345- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveReadRequest:(CBATTRequest *)request &#123; if ([request.characteristic.UUID isEqual:myCharacteristic.UUID]) &#123; ... 如果该特征’的UUID匹配，则下一个步骤是确保该读请求是不是要求从这是你的特征的值的范围外的索引位置读取。如下面的例子显示，你可以使用一个CBATTRequest对象的偏移属性，以确保读请求不试图适当的范围之外阅读： 12345if (request.offset &gt; myCharacteristic.value.length) &#123; [myPeripheralManager respondToRequest:request withResult:CBATTErrorInvalidOffset]; return; &#125; 假设请求的偏移得到验证，现在设置请求的特征属性的值（默认其值为nil）为偏移量以后的数据： 123request.value = [myCharacteristic.value subdataWithRange:NSMakeRange(request.offset, myCharacteristic.value.length - request.offset)]; 设置了值之后，回复远端Central请求已经成功完成，通过调用CBPeripheralManager类的respondToRequest:withResult:方法 12[myPeripheralManager respondToRequest:request withResult:CBATTErrorSuccess];... 如果characteristics的UUID不匹配或者因为其它的原因不能完成读请求，相反你需要调用e respondToRequest:withResult: 并给出错误的原因 当远程Central一个或者多个Characteristics的发送写请求时，Peripheral Manager的代理方法peripheralManager:didReceiveWriteRequests:将会被调用，此时代理方法，将把这些请求放在包含CBATTRequest对象的数组里传递给Peripheral，当你确定这些请求可以背满足时，用以下方法将数据写入characteristic的值中，如下： 1myCharacteristic.value = request.value; PS:当收到多个请求时，如果其中任何一个不能得到满足，那就不应该满足其中的任何一个请求，然后调用respondToRequest:withResult返回一个错误信息 ###给订阅了的远程Central发送更新的Characteristic值 当连接的远端Central订阅了characteristics的值后，peripheral manager的代理方法会调用peripheralManager:central:didSubscribeToCharacteristic:方法 123456- (void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)centraldidSubscribeToCharacteristic:(CBCharacteristic *)characteristic &#123; NSLog(@&quot;Central subscribed to characteristic %@&quot;, characteristic); ... 使用上述委托方法作为一个线索开始发送中央更新的值.接着，得到characteristic更新的值，然后通过调用CBPeripheralManager类的updateValue:forCharacteristic:onSubscribedCentrals:方法向远端central发送数据。 123NSData *updatedValue = // fetch the characteristic&apos;s new value BOOL didSendValue = [myPeripheralManager updateValue:updatedValue forCharacteristic:characteristic onSubscribedCentrals:nil]; onSubscribedCentrals为nil代表给所有订阅的远端Central发送更新数据，当然你可以指定特定的Central。didSendValue返回是否发送成功，如果用于发送更新值底层队列是满的，则该方法返回NO，然后peripheral manager的代理会调用peripheralManagerIsReadyToUpdateSubscribers:方法，知道发送队列中有足够的空间时，你可以使用它的updateValue:forCharacteristic:onSubscribedCentrals: method方法重新发送更新的值。 PS:当使用通知给已经订阅的远端Central发送一个单一的数据包时，你需要发送所有的更新的数据。介于characteristic值大小的限制，并不是所有的数据都可以通过通知的方式发送，所以在远端Central可以使用 CBPeripheral类的readValueForCharacteristic:方法读取改变的值 技术交流群:494826724","categories":[],"tags":[]},{"title":"BLE 4.0 技术学习（二）中心角色Central","slug":"BLE 4.0 技术学习（二）中心角色Central","date":"2016-04-12T01:19:21.000Z","updated":"2016-09-18T08:31:00.000Z","comments":true,"path":"2016/04/12/BLE 4.0 技术学习（二）中心角色Central/","link":"","permalink":"https://devchao.com/2016/04/12/BLE 4.0 技术学习（二）中心角色Central/","excerpt":"","text":"BLE 4.0 技术学习（二）中心Central 本章介绍以Central为本地端，以Peripheral为远端 执行常见的中心角色任务实现在蓝牙低功耗通信的核心作用的设备执行许多常见任务，例如，发现和连接可用外设，探索并与外围设备所提供的数据进行交互。相反，实施外围角色的设备执行一些共同的，但不同的任务，例如，出版和广告服务，并响应读，写和从连接切牙订阅请求。 在本章中，您将学习如何使用蓝牙核心架构从中央侧执行最常见的蓝牙低耗能的任务。下面将帮助您开发的应用程序基于代码的例子来实现您的本地设备上的核心作用。具体来说，您将学习如何去做： 启动中央管理器对象 发现并连接到是广告外围设备 探索外围设备上的数据您已经连接到后 送读取和写入请求到一个外设的服务的特性值 订阅特征的价值，当它被更新为被通知 在下一章中，您将学习如何开发你的应用程序来实现您的本地设备上的外围设备的作用。 初始化一个中央管理器由于CBCentralManager对象是本地中心设备的蓝牙核心的面向对象的代表性，必须分配和初始化一个中央管理器实例，然后才能执行任何蓝牙低能量交易。用CBCentralManager 的实例方法，这样你就可以通过调用initWithDelegate启动你的中央管理器，如下： 12myCentralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil options:nil]; 当你创建了central manager后，central manager就会掉用 centralManagerDidUpdateState:方法， 发现正在广播的外设你可依通过以下方法扫描发现广播的外设: 1[myCentralManager scanForPeripheralsWithServices:nil options:nil]; 注意：如果您的第一个参数指定为零，中央管理器返回所有发现的外设，不管他们支持的服务。在实际的应用程序，你可能会指定CBUUID对象，其中每一个代表一个外设广告服务的通用唯一标识符（UUID）的数组。当您指定服务的UUID的数组，中央管理器只返回宣传这些服务的外设，让您扫描只为您可能感兴趣的设备的UUID，以及CBUUID对象代表他们，更详细地在服务讨论和特性由UUID的识别。 当你调用 scanForPeripheralsWithServices:options:方法来发现哪些外设可用时，每次一个外设被发现后，central manager 调用centralManager：didDiscoverPeripheral：advertisementData：RSSI：，被发现的任何外设返回为一个CBPeripheral对象。如下面所示，您可以实现此委托方法列出发现任何外围设备： 1234567- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI &#123; NSLog(@&quot;Discovered %@&quot;, peripheral.name); ... 当你发现你感兴趣的连接外围设备，以节省电源停止扫描其他设备。 12[myCentralManager stopScan]; NSLog(@&quot;Scanning stopped&quot;); 连接已经发现的外围设备通过向CBCentralManager对象发送connectPeripheral:peripheral消息连接已经发现的外设。 1[myCentralManager connectPeripheral:peripheral options:nil]; 连接成功后central manager代理会调用centralManager:didConnectPeripheral: 代理 你开始与周边的互动之前，您应该设置外围的委托，以确保它得到适当的回调，就像这样：一般在连接建立之后一般和[peripheral discoverServices:nil]一起放在建立连接之后。 1peripheral.delegate = self; 发现已连接的外设的服务一个外设能以提供很多服务，一个服务可以包含许多Characteristic，发现已经连接的外设的服务用以下代码： 1[peripheral discoverServices:nil]; 注意：在真正的应用程序，你最好不要以nil作为参数传递，因为这样做会返回一个外围设备上的所有可用的服务。由于外围可能包含更多的服务包括了你感兴趣的，发现所有的人都可能浪费电池寿命并且浪费时间。更有可能的是，你会指定你已经知道并且你有兴趣的服务的UUID，智慧地探索外设的数据。 当发现服务后将会掉用peripheral的peripheral:didDiscoverServices: 代理方法 12345678- (void)peripheral:(CBPeripheral *)peripheraldidDiscoverServices:(NSError *)error &#123; for (CBService *service in peripheral.services) &#123; NSLog(@&quot;Discovered service %@&quot;, service); ... &#125; ... 发现服务的特征 假设你已经找到了一个服务，你有兴趣，那么掉用如下方法用与发现服务所包含的特征 12NSLog(@&quot;Discovering characteristics for service %@&quot;, interestingService); [peripheral discoverCharacteristics:nil forService:interestingService]; PS:在真正的app中第一个参数不可能作为nil传递进去，因为这样做会返回一个外设的服务的的所有的特性。由于外设的服务包括很多的特性，其中可能包括你感兴趣的服务，发现所有的特征可能降低电池的使用寿命并且浪费不必要的搜索服务时间，所以一般都会指定你感兴趣的特征的UUID。 发现特征后将会调用代理的peripheral:didDiscoverCharacteristicsForService:error: 123456789- (void)peripheral:(CBPeripheral *)peripheraldidDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error &#123; for (CBCharacteristic *characteristic in service.characteristics) &#123; NSLog(@&quot;Discovered characteristic %@&quot;, characteristic); ... &#125; ... 检索特征的值在发现特征后，可以掉用如下方法来读去特征的值 读取特征的值 12NSLog(@&quot;Reading value for characteristic %@&quot;, interestingCharacteristic); [peripheral readValueForCharacteristic:interestingCharacteristic]; 读取到值后会掉用peripheral:didUpdateValueForCharacteristic:error: 方法，你可以通过这个方法获取特征中的值。 1234567- (void)peripheral:(CBPeripheral *)peripheraldidUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error &#123; NSData *data = characteristic.value; // parse the data as needed ... PS:并非所有的特征的值都是可读的，所以判断改特征的类型是否是CBCharacteristicPropertyRead，如果不是，则peripheral:didUpdateValueForCharacteristic:error中的error将返回一个错误 订阅一个特征的值PS:只有具有CBCharacteristicPropertyNotify属性的特征，在被订阅时会通知远程外设 虽然readValueForCharacteristic:能够读去特征的值，但是它并不会监测到它值的变化，当你订阅了之后你就会收到来自外围的值得更改通知。你可以用过掉用CBPeripheral类的setNotifyValue:forCharacteristic:方法订阅你感兴趣的特征的值的变化。 1[peripheral setNotifyValue:YES forCharacteristic:interestingCharacteristic]; 当你试图去订阅或者取消订阅特征的值时，peripheral会掉用他的代理的peripheral:didUpdateNotificationStateForCharacteristic:error:方法，如果申请请求出错时，error将返回错误信息。 123456789- (void)peripheral:(CBPeripheral *)peripheraldidUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error &#123; if (error) &#123; NSLog(@&quot;Error changing notification state: %@&quot;, [error localizedDescription]); &#125; ... PS:并不是所有的特征的值都允许你去订阅的，你可以在Characteristic Properties中设置它们 在你成功订阅特征的值后，在值发生改变后，Peripheral将会通知你的app，peripheral会掉用它的代理的peripheral:didUpdateValueForCharacteristic:error:方法 写特征的值在一些情况下，比如与蓝牙低功耗数字温度调控器交互时，你可能需要设置房间的温度，如果特征的值时可写的你可以通过掉用CBPeripheral的writeValue:forCharacteristic:type: 123NSLog(@&quot;Writing value for characteristic %@&quot;, interestingCharacteristic); [peripheral writeValue:dataToWrite forCharacteristic:interestingCharacteristic type:CBCharacteristicWriteWithResponse]; 当你尝试去写一个特征的值时，需要指定写的类型，在上面的例子中，被指定为CBCharacteristicWriteWithResponse，这指示外围设备让你的app知道写入是否成功。设置为CBCharacteristicWriteWithResponse时Peripheral的代理将会掉用peripheral:didWriteValueForCharacteristic:error:方法， 123456789- (void)peripheral:(CBPeripheral *)peripheraldidWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error &#123; if (error) &#123; NSLog(@&quot;Error writing characteristic value: %@&quot;, [error localizedDescription]); &#125; ... PS:Characteristics可能只允许某些类型的写操作！有关定义如下： 123456789101112typedef enum &#123; CBCharacteristicPropertyBroadcast = 0x01, CBCharacteristicPropertyRead = 0x02, CBCharacteristicPropertyWriteWithoutResponse = 0x04, CBCharacteristicPropertyWrite = 0x08, CBCharacteristicPropertyNotify = 0x10, CBCharacteristicPropertyIndicate = 0x20, CBCharacteristicPropertyAuthenticatedSignedWrites = 0x40, CBCharacteristicPropertyExtendedProperties = 0x80, CBCharacteristicPropertyNotifyEncryptionRequired = 0x100, CBCharacteristicPropertyIndicateEncryptionRequired = 0x200,&#125; CBCharacteristicProperties; 技术交流群:494826724","categories":[],"tags":[]},{"title":"BLE 4.0 技术学习（一）core bluetooth 概述","slug":"BLE 4.0 技术学习（一）core bluetooth 概述","date":"2016-04-12T01:14:05.000Z","updated":"2016-09-18T08:31:32.000Z","comments":true,"path":"2016/04/12/BLE 4.0 技术学习（一）core bluetooth 概述/","link":"","permalink":"https://devchao.com/2016/04/12/BLE 4.0 技术学习（一）core bluetooth 概述/","excerpt":"","text":"BLE 4.0 技术学习（一） ###core bluetooth 概述 Core Bluetooth framework能够实现iOS 或者 Mac app与蓝牙低耗能设备交互。你的app能够和蓝牙低耗能，甚至是与其他iOS设备发现，探索，交互，例如心率监视器，数字恒温器。 蓝牙4.0规范的框架是一个抽象与低能耗设备使用。它隐藏了很多的低层细节规范,从而使它更容易为你开发与蓝牙低耗能设备交互的应用程序。因为框架是基于规范,一些概念和术语的规范已经采用了。本章向您介绍关键术语和概念,你需要知道开始开发应用程序使用蓝牙核心框架。 I.中央（Central）和外围设备（Peripheral）和他们在蓝牙通信担任的角色在蓝牙低耗能交互中有两个主要的参与者：central和peripheral，基于传统的客户机-服务器体系结构,外围通常有数据所需的其他设备。中央通常使用外围设备提供的信息来完成一些特定的任务。如图1 - 1所示,例如,一个心率监视器可能有用的信息,你的Mac或iOS应用程序可能需要为了以用户友好的方式显示用户的心率。 ###Central发现并连接正在广播的Peripheral 外围设备发出一些广播的数据与他们的广告包。广告包是一个相对较小的包的数据，可能包含关于一个外围的信息,如外围的名称和主要功能。例如,数码恒温器可能只广播,它提供了当前房间的温度。对于蓝牙低能耗，外围设备的“广播”把他们展现的淋漓尽致。,另一方面,中央可以扫描和监听任何外围设备感兴趣的广告信息,如图1 - 2所示。中央可以要求连接到任何外围,发现广播。如图： ###Peripheral 的外围数据结构形式 连接到外围的目的是开始探索和与它提供的数据交互。 外围设备可能包含一个或多个服务或关于他们的连接信号强度提供有用的信息。服务是一个集合的数据和相关行为完成一个功能或特性的设备(或部分设备)。例如心率监测器,一个服务可能是公开的心率数据监测心率的传感器。服务本身是由一个或者多个特征组成的。一个特征对周边的服务提供了更多的详情。例如,刚刚描述的心率服务可能包含一个身体位置的特征和一个传输心率数据的另一个特征。图1 - 3显示了一个可能的心率监测器的服务的结构和特点。如图： ###Central探索并与外设数据交互 之后，中央已成功建立到外设的连接，它可以发现全方位的服务和特色的外设所提供的（广告数据可能只包含可用服务的一小部分）。 中央还可以与外设的服务，通过读取或写入该服务的特性值交互。例如，应用程式可从数字恒温请求当前室温，或者它可以提供与在其上设置的房间的温度的值的恒温器。 II.Central Peripheral和Peripheral的数据表示在Central这边： 本地的Central，远端的Peripheral 在中心侧，本地中央装置是由一个CBCentralManager对象表示。使用这些对象来管理发现或远程连接外围设备（由CBPeripheral对象表示），其中包括扫描，发现和连接到广告外设。图1-4显示切牙和远程外设如何在本地核心蓝牙框架的代表。 远端外设的数据由CBService和CBCharacteristic对象表示 当你在和远程外围设备（由CBPeripheral对象表示）交互服务和特性数据时，一个远程外设的服务由CBService对象表示。同样，一个远程外设的服务的特性由CBCharacteristic对象表示。图1-5示出了一个远程外设的服务和特征的基本结构。如图： 在Peripheral这边 本地的Peripheral和远端的Central 在外围侧，本地外围装置由CBPeripheralManager对象表示。这些对象用于服务和特征的本地外围设备的数据库中管理发布的服务和宣传这些服务，以远程中央设备（由CBCentral对象表示）。外围对象还用于响应读写这些远程CENTR来的请求。一个本地外围的数据由CBMutableService和CBMutableCharacteristic对象表示 当您在用本地外围设备（由CBPeripheralManager对象表示）与远程中心设备进行数据的交互，您正在处理的服务和特性可变版本。在核心蓝牙框架中，一个本地外围的服务由CBMutableService对象表示。类似地，本地外设的服务的特性由CBMutableCharacteristic对象表示。图1-7示出的本地外设的服务和特征的基本结构。 技术交流群:494826724","categories":[],"tags":[]},{"title":"利用长按手势移动tableviewcell","slug":"利用长按手势移动tableviewcell","date":"2016-03-17T03:01:18.000Z","updated":"2017-03-20T08:29:50.000Z","comments":true,"path":"2016/03/17/利用长按手势移动tableviewcell/","link":"","permalink":"https://devchao.com/2016/03/17/利用长按手势移动tableviewcell/","excerpt":"","text":"利用长按手势移动Table View Cells废话少说直接上步骤： 给table view添加长按手势 获取长按的位置，并找出该位置对应的cell的indexPath，从而找到table view cell。 在长按开始时，获取cell的一个snapshot并将其放大，通过改变snapshot的透明度实现渐变的效果，将cell的背景设置为黑色，以显示出cell浮动的感觉。 在长按状态改变时，移动cell的位置。 在长按取消或者结束时，还原snapshot，和table view 的背景，为了更形象的让用户感觉到时慢慢放下。 具体的代码如下： 在viewdidload中添加长按手势： 123// 添加移动手势 UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc]initWithTarget:self action:@selector(longPressTableView:)]; [_tableView addGestureRecognizer:longPress]; 在长按事件中添加如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374-(void)longPressTableView:(id)sender&#123; UILongPressGestureRecognizer *longPressGes = (UILongPressGestureRecognizer *)sender; UIGestureRecognizerState state = longPressGes.state; CGPoint location = [longPressGes locationInView:_tableView]; NSIndexPath *indexPath = [_tableView indexPathForRowAtPoint:location]; static UIView *snapShot = nil; static NSIndexPath *sourceIndexPath = nil; switch (state) &#123; case UIGestureRecognizerStateBegan: &#123; if (indexPath) &#123; sourceIndexPath = indexPath; UITableViewCell *cell = [_tableView cellForRowAtIndexPath:indexPath]; snapShot = [self customeSnapShotFromView:cell]; __block CGPoint center = cell.center; snapShot.center = center; snapShot.alpha = 0.0f; [_tableView addSubview:snapShot]; [UIView animateWithDuration:0.25 animations:^&#123; center = CGPointMake(center.x, location.y); snapShot.center = center; snapShot.transform = CGAffineTransformScale(snapShot.transform, 1.05, 1.05); snapShot.alpha = 0.98; cell.backgroundColor = [UIColor blackColor]; &#125;]; &#125; &#125; break; case UIGestureRecognizerStateChanged: &#123; CGPoint center = snapShot.center; snapShot.center = CGPointMake(center.x, location.y); if (indexPath &amp;&amp; ![indexPath isEqual:sourceIndexPath]) &#123; [saveAry exchangeObjectAtIndex:indexPath.row withObjectAtIndex:sourceIndexPath.row]; [_tableView moveRowAtIndexPath:sourceIndexPath toIndexPath:indexPath]; sourceIndexPath = indexPath; &#125; &#125; break; default: &#123; UITableViewCell *cell = [_tableView cellForRowAtIndexPath:sourceIndexPath]; [UIView animateWithDuration:0.5 animations:^&#123; snapShot.center = cell.center; snapShot.transform = CGAffineTransformIdentity; snapShot.alpha = 0.0f; cell.backgroundColor = [UIColor whiteColor]; &#125; completion:^(BOOL finished) &#123; [snapShot removeFromSuperview]; snapShot = nil; &#125;]; sourceIndexPath = nil; &#125; break; &#125; &#125; 获取截屏 12345678910-(UIView *)customeSnapShotFromView:(UIView *)inputView&#123; UIView *snapShotView = [inputView snapshotViewAfterScreenUpdates:YES]; snapShotView.layer.masksToBounds = NO; snapShotView.layer.cornerRadius = 0.0f; snapShotView.layer.shadowOffset = CGSizeMake(-0.5, 0); snapShotView.layer.shadowRadius = 5.0f; snapShotView.layer.shadowOpacity = 0.4; return snapShotView;&#125; 技术交流群:494826724","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://devchao.com/tags/ios/"}]},{"title":"iOS设备旋转问题实践总结","slug":"iOS设备旋转问题实践总结","date":"2016-03-08T09:15:53.000Z","updated":"2016-09-18T08:35:04.000Z","comments":true,"path":"2016/03/08/iOS设备旋转问题实践总结/","link":"","permalink":"https://devchao.com/2016/03/08/iOS设备旋转问题实践总结/","excerpt":"","text":"iOS设备旋转问题实践总结 基础知识两种orientation 1.device orientation,设备的物理方向，由类型UIDeviceOrientation表示，当前设备方向获取方式： 1[UIDevice currentDevice].orientation 该属性的值一般是与当前设备方向保持一致的，但须注意以下几点：官方Api 1@property(nonatomic,readonly) UIDeviceOrientation orientation; // return current device orientation. this will return UIDeviceOrientationUnknown unless device orientation notifications are being generated. 所以用下面的方法比较靠谱: 12345 if (![UIDevice currentDevice].generatesDeviceOrientationNotifications) &#123; [[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications]; &#125;NSLog(@&quot;%d&quot;,[UIDevice currentDevice].orientation);[[UIDevice currentDevice] endGeneratingDeviceOrientationNotifications]; PS:如果关闭了系统的横竖屏切换开关，即系统层级只允许竖屏时，再通过上述方式获取到的设备方向将永远是UIDeviceOrientationUnknown。可以通过Core Motion中的CMMotionManager来获取当前设备方向。 2.interface orientation,当前界面显示的方向，由类型UIInterfaceOrientation表示。当前界面显示方向有以下两种方式获取 12 NSLog(@&quot;%d&quot;,[UIApplication sharedApplication].statusBarOrientation);NSLog(@&quot;%d&quot;,viewController.interfaceOrientation);//ios8被弃用 3.二者区别：通过UIDevice获取到的设备方向在手机旋转时是实时的，通过UIApplication的statusBar或者viewController(已被弃用)获取到的界面方向在下述方法： 下面方法调用后才改变UIApplication的statusBar，而UIDevice得orientation将立即被改变 iOS8以后调用： 1-(void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator: (id&lt;UIViewControllerTransitionCoordinator&gt;)coordinator iOS8以前调用 1- (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration: 相关的两个APIios8后UIViewController又出了两个API: 12345//新出现的API- (void)willTransitionToTraitCollection:(UITraitCollection *)newCollection withTransitionCoordinator:(id &lt;UIViewControllerTransitionCoordinator&gt;)coordinator NS_AVAILABLE_IOS(8_0);//用于下述废弃的Api的替代品- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id &lt;UIViewControllerTransitionCoordinator&gt;)coordinator NS_AVAILABLE_IOS(8_0); 并废弃了以下API 123- (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration- (void)willAnimateRotationToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration 其中- (void)willTransitionToTraitCollection:***后，在size class的设备compact到regular转变时，会调用的Api，官方这么说：This method is called when the view controller’s trait collection is changed by its parent. 而- (void)viewWillTransitionToSize:**则会在控制器的视图View发生变化时调用，官方这么说：This method is called when the view controller’s view’s size is changed by its parent 用以上API实现监控设备的方向 1.在视图将要出现时添加通知对象,开始监控设备方向 1234[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(deviceOrientationDidChanged:) name:UIDeviceOrientationDidChangeNotification object:nil]; if (![[UIDevice currentDevice] isGeneratingDeviceOrientationNotifications]) &#123; [[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications]; &#125; 2.视图消失时销毁通知和关闭设备方向获取 12[[NSNotificationCenter defaultCenter] removeObserver:self name:UIDeviceOrientationDidChangeNotification object:nil]; [[UIDevice currentDevice] endGeneratingDeviceOrientationNotifications]; 3.添加通知事件 123456789101112131415161718 -(void)deviceOrientationDidChanged:(NSNotification *)sender&#123;// UIInterfaceOrientation or = [UIApplication sharedApplication].statusBarOrientation;// 获取应用程序显示方向 --- 上述方法第一次程序启动时获取的设备方向正确，在旋转时获得的值和实际值相反 // 此处我们采用设备的方向， UIDeviceOrientation or = [UIDevice currentDevice].orientation;// 获取设备的方向 if (or == UIDeviceOrientationUnknown) &#123; NSLog(@&quot;未知方向&quot;); &#125; if (or == UIInterfaceOrientationLandscapeLeft || or == UIInterfaceOrientationLandscapeRight) &#123;// 横屏 NSLog(@&quot;横屏&quot;); &#125;else &#123; NSLog(@&quot;竖屏&quot;); &#125;&#125; 其他方法实现屏幕旋转如果你重写了viewWillTransitionToSize：**方法，这个方法也会被调用。（必须call他的super方法），如： 123456789101112131415-(void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id&lt;UIViewControllerTransitionCoordinator&gt;)coordinator&#123;[super viewWillTransitionToSize:size withTransitionCoordinator:coordinator];// UIInterfaceOrientation or = [UIApplication sharedApplication].statusBarOrientation; UIDeviceOrientation or = [UIDevice currentDevice].orientation; if (or == UIDeviceOrientationUnknown) &#123; NSLog(@&quot;未知方向&quot;); &#125; if (or == UIInterfaceOrientationLandscapeLeft || or == UIInterfaceOrientationLandscapeRight) &#123; // 横屏 NSLog(@&quot;viewWillTransitionToSize横屏&quot;); &#125;else &#123; NSLog(@&quot;viewWillTransitionToSize竖屏&quot;); &#125;&#125; trait collection变化时调用willTransitionToTraitCollection:**1234567891011121314- (void)willTransitionToTraitCollection:(UITraitCollection *)newCollection withTransitionCoordinator:(id &lt;UIViewControllerTransitionCoordinator&gt;)coordinator&#123; [super willTransitionToTraitCollection:newCollection withTransitionCoordinator:coordinator]; if (newCollection.horizontalSizeClass == UIUserInterfaceSizeClassCompact) &#123; NSLog(@&quot;水平方向为compact&quot;); &#125;else&#123; NSLog(@&quot;水平方向为regular&quot;); &#125; if (newCollection.verticalSizeClass == UIUserInterfaceSizeClassRegular) &#123; NSLog(@&quot;竖直方向为regular&quot;); &#125;else&#123; NSLog(@&quot;竖直方向为compact&quot;); &#125;&#125; 所有.m文件代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//// ViewController.m// RoteDemo//// Created by yachaocn on 16/3/8.// Copyright © 2016年 NavchinaMacBook. All rights reserved.//#import &quot;ViewController.h&quot;@interface ViewController ()@end@implementation ViewController-(void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(deviceOrientationDidChanged:) name:UIDeviceOrientationDidChangeNotification object:nil]; if (![[UIDevice currentDevice] isGeneratingDeviceOrientationNotifications]) &#123; [[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications]; &#125; &#125;-(void)viewWillDisappear:(BOOL)animated&#123; [super viewWillAppear:animated]; [[NSNotificationCenter defaultCenter] removeObserver:self name:UIDeviceOrientationDidChangeNotification object:nil]; [[UIDevice currentDevice] endGeneratingDeviceOrientationNotifications]; &#125;- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib.&#125;-(void)deviceOrientationDidChanged:(NSNotification *)sender&#123;// UIInterfaceOrientation or = [UIApplication sharedApplication].statusBarOrientation;// 获取应用程序显示方向 --- 上述方法第一次程序启动时获取的设备方向正确，在旋转时获得的值和实际值相反 // 此处我们采用设备的方向， UIDeviceOrientation or = [UIDevice currentDevice].orientation;// 获取设备的方向 if (or == UIDeviceOrientationUnknown) &#123; NSLog(@&quot;未知方向&quot;); &#125; if (or == UIInterfaceOrientationLandscapeLeft || or == UIInterfaceOrientationLandscapeRight) &#123;// 横屏 NSLog(@&quot;横屏&quot;); &#125;else &#123; NSLog(@&quot;竖屏&quot;); &#125;&#125;-(void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id&lt;UIViewControllerTransitionCoordinator&gt;)coordinator&#123; [super viewWillTransitionToSize:size withTransitionCoordinator:coordinator];// UIInterfaceOrientation or = [UIApplication sharedApplication].statusBarOrientation; UIDeviceOrientation or = [UIDevice currentDevice].orientation; if (or == UIDeviceOrientationUnknown) &#123; NSLog(@&quot;未知方向&quot;); &#125; if (or == UIInterfaceOrientationLandscapeLeft || or == UIInterfaceOrientationLandscapeRight) &#123; // 横屏 NSLog(@&quot;viewWillTransitionToSize横屏&quot;); &#125;else &#123; NSLog(@&quot;viewWillTransitionToSize竖屏&quot;); &#125;&#125;- (void)willTransitionToTraitCollection:(UITraitCollection *)newCollection withTransitionCoordinator:(id &lt;UIViewControllerTransitionCoordinator&gt;)coordinator&#123; [super willTransitionToTraitCollection:newCollection withTransitionCoordinator:coordinator]; if (newCollection.horizontalSizeClass == UIUserInterfaceSizeClassCompact) &#123; NSLog(@&quot;水平方向为compact&quot;); &#125;else&#123; NSLog(@&quot;水平方向为regular&quot;); &#125; if (newCollection.verticalSizeClass == UIUserInterfaceSizeClassRegular) &#123; NSLog(@&quot;竖直方向为regular&quot;); &#125;else&#123; NSLog(@&quot;竖直方向为compact&quot;); &#125;&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end 技术交流群:494826724","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://devchao.com/tags/ios/"}]},{"title":"申请iOS企业开发者账号","slug":"申请iOS企业开发者账号","date":"2016-03-05T01:59:49.000Z","updated":"2016-09-18T08:32:30.000Z","comments":true,"path":"2016/03/05/申请iOS企业开发者账号/","link":"","permalink":"https://devchao.com/2016/03/05/申请iOS企业开发者账号/","excerpt":"","text":"ios apple企业账号申请流程 1.Apple开发者账号分三种，个人和公司账号（99刀） 和企业账号（299刀） 2.企业账号的好处 1.在公司内部发布app。 2.在各个设备上使用 3.可以获得苹果代码级别的支持。 3.注册前必备，公司DUNS（邓白氏编码） 邓白氏简介 邓白氏编码申请地址 按照提示如实填写即可，填完提交后很快收到邮件。剩下就等着电话核实了，注册完成后1到2个工作日会受到邮件，其中包含邓白氏编码数字，剩下就是等14个工作日后去交299刀了。苹果公司同步这些数据需要时间的. 4.注册企业账号 企业账号申请地址 等待邓白氏码同步到苹果公司的服务器后，把邓白氏码填进去了，Review&amp;submit完成了，然后就是等待苹果公司的电话确认信息了。他会问你：这企业账号主要用来干嘛？然后告诉你这个账号主要是给企业内部使用，不能外部使用，如果有专人陪同情况下可以给客户演示程序，再然后就是等待美国苹果公司来的电话，告诉你审核成功或者失败！ 5.收到激活邮件，激活，账号可以使用了 技术交流群:494826724","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://devchao.com/tags/ios/"}]},{"title":"以无线方式安装企业内部应用部署参考","slug":"以无线方式安装企业内部应用部署参考","date":"2016-03-05T01:49:34.000Z","updated":"2016-09-18T08:33:02.000Z","comments":true,"path":"2016/03/05/以无线方式安装企业内部应用部署参考/","link":"","permalink":"https://devchao.com/2016/03/05/以无线方式安装企业内部应用部署参考/","excerpt":"","text":"以无线方式安装企业内部应用部署参考原文在apple官网iOS部署参考 iOS 支持以无线方式安装自定的企业内部应用，而无需使用 iTunes 或 App Store。应用的格式必须为 .ipa，并且使用企业内部预置描述文件进行构建。无线安装要求： XML 清单文件（本节已有描述） 可让设备访问 Apple iTunes 服务器的网络配置 对于 iOS 7.1 或更高版本，使用 HTTPS 为了安装应用，用户使用特殊的 URL 前缀从您的网站上下载清单文件。您可以通过短信或电子邮件分发用于下载清单文件的 URL，或将其嵌入创建的另一企业应用中。 您负责设计和托管用于分发应用的网站。请确定用户已通过认证（可能是使用基本认证或基于目录的认证），并确定网站可通过内联网或互联网进行访问。您可以将应用和清单文件放入隐藏目录或任何可使用 HTTPS 读取的位置。 【注】创建自助服务门户时，请考虑在用户的主屏幕中添加一个 Web Clip，以便他们可以轻松返回门户以获取更多信息，如新的配置描述文件、推荐的 App Store 应用以及允许他们在 MDM 解决方案中进行注册。 准备以无线方式分发的企业内部应用 为准备以无线方式分发的企业内部应用，请构建归档版本（.ipa 文件）和用于启用无线分发和应用安装的清单文件。 使用 Xcode 来创建应用归档。使用分发证书给应用签名，并在归档中包括企业内部预置描述文件。有关构建和归档应用的更多信息，请访问 iOS Dev Center 网站（iOS 开发者中心），或参阅 Xcode“Help”（帮助）菜单中可用的《Xcode User Guide》（Xcode 使用手册）。 关于无线清单文件 清单文件是一个 XML plist 文件，可供 Apple 设备用来从您的 Web 服务器上查找、下载和安装应用。清单文件由 Xcode 创建，使用的是您在共享用于企业分发的归档应用时所提供的信息。 以下栏是必填项： URL：应用 (.ipa) 文件的完全限定 HTTPS URL display-image：57 x 57 像素的 PNG 图像，在下载和安装过程中显示。指定图像的完全限定 URL full-size-image：512 x 512 像素的 PNG 图像，表示 iTunes 中相应的应用 bundle-identifier：应用的包标识符，与 Xcode 项目中指定的完全一样 bundle-version：应用的包版本，在 Xcode 项目中指定 title：下载和安装过程中显示的应用的名称 样本清单文件还包含可选键。例如，如果应用文件太大，并且想要在执行错误检验（TCP 通信通常会执行该检验）的基础上确保下载的完整性，可以使用 MD5 键。 通过指定项目数组的附加成员，您可以使用一个清单文件安装多个应用。 构建网站 将这些项目上传到网站上可供已认证的用户访问的区域： 应用 (.ipa) 文件 清单 (.plist) 文件 您的网站可以是链接到清单文件的单个页面。用户轻点 Web 链接后会下载清单文件，并触发下载和安装。 以下是示例链接： 1&lt;a href=&quot;itms-services://?action=download-manifest&amp;url=https://example.com/manifest.plist&quot;&gt;Install App&lt;/a&gt; Install my App 请勿添加归档应用 (.ipa) 的网站链接。载入清单文件时，设备会下载该 .ipa 文件。虽然 URL 的协议部分是“itms-services”，但 iTunes Store 并不参与此过程。 此外，请确定 .ipa 文件可通过 HTTPS 进行访问，并且您的站点已使用 iOS 信任的证书进行了签名。如果自签名证书没有受信任的锚点并且无法由 iOS 设备验证，安装会失败。 设定服务器 MIME 类型 您可能需要配置 Web 服务器，让清单文件和应用文件可正确传输。 对于 OS X Server，请将 MIME 类型添加到 Web 服务的 MIME 类型设置： application/octet-stream ipa text/xml plist 对于微软的互联网信息服务器 (IIS)，请使用 IIS Manager 在服务器的“属性”页面中添加 MIME 类型： .ipa application/octet-stream .plist text/xml 无线 iOS 应用分发故障诊断 如果无线应用分发失败，并显示“无法下载”信息： 请确定应用已正确进行签名。测试方法是使用 Apple Configurator 2 将它安装到设备上，然后查看是否发生错误。 请确定清单文件的链接是否正确，清单文件是否可供网络用户访问。 请确定 .ipa 文件（在清单文件中）的 URL 是否正确，并且该 .ipa 文件是否可供网络用户通过 HTTPS 访问。 网络配置要求 如果设备连接到封闭式内部网络，那么您必须允许它访问以下站点： ax.init.itunes.apple.com：使用蜂窝移动网络下载应用时，设备会限制其当前文件大小。如果无法访问此站点，安装可能会失败。 ocsp.apple.com：设备会联系此网站，检查用来给预置描述文件签名的分发证书状态。 提供更新的应用 您自己分发的应用不会自动更新。有新版本时，应通知用户进行更新并指导他们安装应用。请考虑让应用检查更新，并在打开应用时通知用户。请确保通知中提供了 itms-services 链接。您还可以使用应用内部的 openURL 来安装更新。 如果想要用户保留他们设备上储存的应用数据，请确保新版本与要替换的版本使用的捆绑标识符相同，并告知用户在安装新版本之前不要删除旧版本。 预置描述文件过期之前，请访问 iOS for Developers 网站（面向开发者的 iOS）为应用创建新描述文件。对于首次安装应用的用户，请使用新预置描述文件创建新应用归档 (.ipa)。 如果用户已有该应用，您不妨设定发布下一个版本的时间，并在该版本中包括新预置描述文件，这样用户在使用应用工作时不会被打断。如果不想这样做，您可以仅分发新的 .mobileprovision 文件，这样用户便不必再次安装该应用。新的预置描述文件会覆盖应用归档中已有的描述文件。 分发预置描述文件自签发之日起 12 个月后过期。过期后，系统会删除描述文件，应用将不会启动。 您可以使用 MDM 安装和管理预置描述文件，然后用户通过应用更新或使用 MDM 进行下载并安装。 如果您的分发证书过期，应用将不会启动，而您需要使用新的分发证书来重新构建应用。分发证书自签发之日起三年内有效，或者在您的 Apple Developer Enterprise Program（Apple 开发者企业级计划）成员资格过期之前一直有效，二者以先到者为准。若要防止证书过期，请确保在成员资格过期之前先进行续订。 您可以拥有同时处于活跃状态的两个证书，并且它们彼此独立。第二个证书提供了一个重叠期，让您能够在第一个证书过期前更新应用。从 iOS Dev Center 请求第二个分发证书时，请确保不要撤销第一个证书。 证书验证 用户首次打开应用时，系统会通过联系 Apple 的 OCSP 服务器来验证分发证书。如果证书已撤销，应用将不会启动。为了验证状态，设备必须能够访问 ocsp.apple.com。 OCSP 响应会在设备上缓存一段时间（由 OCSP 服务器指定），当前为 3 到 7 天之间。在重新启动设备和缓存的响应过期之前，将不会再次检查证书的有效性。如果当时收到撤销命令，系统将阻止应用运行。 【警告】撤销分发证书会导致使用该证书签名的所有应用失效。只有万不得已时才应撤销证书，比如确定专用密钥已丢失或确信证书已遭破解。 示例 iOS 应用清单文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;!-- array of downloads.--&gt; &lt;key&gt;items&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;!-- an array of assets to download --&gt; &lt;key&gt;assets&lt;/key&gt; &lt;array&gt; &lt;!-- software-package: the ipa to install.--&gt; &lt;dict&gt; &lt;!-- required. the asset kind.--&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software-package&lt;/string&gt; &lt;!-- optional. md5 every n bytes. will restart a chunk if md5 fails.--&gt; &lt;key&gt;md5-size&lt;/key&gt; &lt;integer&gt;10485760&lt;/integer&gt; &lt;!-- optional. array of md5 hashes for each &quot;md5-size&quot; sized chunk.--&gt; &lt;key&gt;md5s&lt;/key&gt; &lt;array&gt; &lt;string&gt;41fa64bb7a7cae5a46bfb45821ac8bba&lt;/string&gt; &lt;string&gt;51fa64bb7a7cae5a46bfb45821ac8bba&lt;/string&gt; &lt;/array&gt; &lt;!-- required. the URL of the file to download.--&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://www.example.com/apps/foo.ipa&lt;/string&gt; &lt;/dict&gt; &lt;!-- display-image: the icon to display during download.--&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;display-image&lt;/string&gt; &lt;!-- optional. indicates if icon needs shine effect applied.--&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://www.example.com/image.57x57.png&lt;/string&gt; &lt;/dict&gt; &lt;!-- full-size-image: the large 512x512 icon used by iTunes.--&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;full-size-image&lt;/string&gt; &lt;!-- optional. one md5 hash for the entire file.--&gt; &lt;key&gt;md5&lt;/key&gt; &lt;string&gt;61fa64bb7a7cae5a46bfb45821ac8bba&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt;&lt;string&gt;https://www.example.com/image.512x512.jpg&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt;&lt;key&gt;metadata&lt;/key&gt; &lt;dict&gt; &lt;!-- required --&gt; &lt;key&gt;bundle-identifier&lt;/key&gt; &lt;string&gt;com.example.fooapp&lt;/string&gt; &lt;!-- optional (software only) --&gt; &lt;key&gt;bundle-version&lt;/key&gt; &lt;string&gt;1.0&lt;/string&gt; &lt;!-- required. the download kind.--&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software&lt;/string&gt; &lt;!-- optional. displayed during download; typically company name --&gt; &lt;key&gt;subtitle&lt;/key&gt; &lt;string&gt;Apple&lt;/string&gt; &lt;!-- required. the title to display during the download.--&gt; &lt;key&gt;title&lt;/key&gt; &lt;string&gt;Example Corporate App&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/array&gt;&lt;/dict&gt;&lt;/plist&gt; 技术交流群:494826724","categories":[],"tags":[{"name":"ios部署","slug":"ios部署","permalink":"https://devchao.com/tags/ios部署/"}]},{"title":"以无线方式安装企业内部应用","slug":"以无线方式安装企业内部应用","date":"2016-03-04T09:43:03.000Z","updated":"2017-01-20T03:32:38.000Z","comments":true,"path":"2016/03/04/以无线方式安装企业内部应用/","link":"","permalink":"https://devchao.com/2016/03/04/以无线方式安装企业内部应用/","excerpt":"","text":"以无线方式安装企业内部应用参考： iOS部署参考–若打不开请点击这里 I.申请企业开发者账号 提供邓白氏编码和其他资料给苹果申请企业帐号,参见申请企业开发者账号 II.创建项目-打包app 点击prutuct &gt; Archive,选择Save for Enterprise Deployment 选择企业账号 选择导出方式 启用自动生成mainifest.plist用于无线安装应用 填写.ipa文件所在地址APP URL、imageURL 123456- URL：应用 (.ipa) 文件的完全限定 HTTPS URL - display-image：57 x 57 像素的 PNG 图像，在下载和安装过程中显示。指定图像的完全限定 URL - full-size-image：512 x 512 像素的 PNG 图像，表示 iTunes 中相应的应用 - bundle-identifier：应用的包标识符，与 Xcode 项目中指定的完全一样 - bundle-version：应用的包版本，在 Xcode 项目中指定 - title：下载和安装过程中显示的应用的名称 选择Export，导出ipa，此时你可以看到在打包的文件下多生成一个mainifest.plist，此plist文件用于iOS设备解析，并自动下载应用使用。 III.构建网站首先购买SSL证书， 然后再服务器上安装SSL证书 购买证书就不说了吧，掏钱的东西，一般都很简单，只要点购买-点掏钱就完事儿了。 安装服务器证书,参见http://www.itrus.cn/html/fuwuyuzhichi/fuwuqizhengshuanzhuangpeizhizhinan/431.html在浏览器上可以使用https://www.domain.com浏览， 并且https是绿色受信任的才可以。 将这些项目上传到网站上可供已认证的用户访问的区域: (plist文件上传到网络空间，生成http链接（iOS6）或https链接（iOS7 之后），可下载这个plist文件，同时ipa也放到网络空间，并保证plist文件中的下载链接指向这个ipa) 应用 (.ipa) 文件 清单 (.plist) 文件 您的网站可以是链接到清单文件的单个页面。用户轻点 Web 链接后会下载清单文件，并触发下载和安装。以下是示例链接： 1&lt;a href=&quot;itms-services://?action=download-manifest&amp;url=https://example.com/manifest.plist&quot;&gt;Install App&lt;/a&gt; Install App 请勿添加归档应用 (.ipa) 的网站链接。载入清单文件时，设备会下载该 .ipa 文件。虽然 URL 的协议部分是“itms-services”，但 iTunes Store 并不参与此过程。此外，请确定 .ipa 文件可通过 HTTPS 进行访问，并且您的站点已使用 iOS 信任的证书进行了签名。如果自签名证书没有受信任的锚点并且无法由 iOS 设备验证，安装会失败。 当用户下载这个plist文件后，iOS系统会自行解析xml，然后分析ipa证书等，然后安装 设定服务器 MIME 类型 参见http://jingyan.baidu.com/article/a3aad71aa5fbfbb1fb0096b1.html 您可能需要配置 Web 服务器，让清单文件和应用文件可正确传输。 对于 OS X Server，请将 MIME 类型添加到 Web 服务的 MIME 类型设置： application/octet-stream ipa text/xml plist 对于微软的互联网信息服务器 (IIS)，请使用 IIS Manager 在服务器的“属性”页面中添加 MIME 类型： .ipa application/octet-stream .plist text/xml 网络配置要求 如果设备连接到封闭式内部网络，那么您必须允许它访问以下站点： ax.init.itunes.apple.com：使用蜂窝移动网络下载应用时，设备会限制其当前文件大小。如果无法访问此站点，安装可能会失败。 ocsp.apple.com：设备会联系此网站，检查用来给预置描述文件签名的分发证书状态。 证书验证 用户首次打开应用时，系统会通过联系 Apple 的 OCSP 服务器来验证分发证书。如果证书已撤销，应用将不会启动。为了验证状态，设备必须能够访问 ocsp.apple.com。 OCSP 响应会在设备上缓存一段时间（由 OCSP 服务器指定），当前为 3 到 7 天之间。在重新启动设备和缓存的响应过期之前，将不会再次检查证书的有效性。如果当时收到撤销命令，系统将阻止应用运行。 【警告】撤销分发证书会导致使用该证书签名的所有应用失效。只有万不得已时才应撤销证书，比如确定专用密钥已丢失或确信证书已遭破解。 示例 iOS 应用清单文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;!-- array of downloads.--&gt; &lt;key&gt;items&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;!-- an array of assets to download --&gt; &lt;key&gt;assets&lt;/key&gt; &lt;array&gt; &lt;!-- software-package: the ipa to install.--&gt; &lt;dict&gt; &lt;!-- required. the asset kind.--&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software-package&lt;/string&gt; &lt;!-- optional. md5 every n bytes. will restart a chunk if md5 fails.--&gt; &lt;key&gt;md5-size&lt;/key&gt; &lt;integer&gt;10485760&lt;/integer&gt; &lt;!-- optional. array of md5 hashes for each &quot;md5-size&quot; sized chunk.--&gt; &lt;key&gt;md5s&lt;/key&gt; &lt;array&gt; &lt;string&gt;41fa64bb7a7cae5a46bfb45821ac8bba&lt;/string&gt; &lt;string&gt;51fa64bb7a7cae5a46bfb45821ac8bba&lt;/string&gt; &lt;/array&gt; &lt;!-- required. the URL of the file to download.--&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://www.example.com/apps/foo.ipa&lt;/string&gt; &lt;/dict&gt; &lt;!-- display-image: the icon to display during download.--&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;display-image&lt;/string&gt; &lt;!-- optional. indicates if icon needs shine effect applied.--&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://www.example.com/image.57x57.png&lt;/string&gt; &lt;/dict&gt; &lt;!-- full-size-image: the large 512x512 icon used by iTunes.--&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;full-size-image&lt;/string&gt; &lt;!-- optional. one md5 hash for the entire file.--&gt; &lt;key&gt;md5&lt;/key&gt; &lt;string&gt;61fa64bb7a7cae5a46bfb45821ac8bba&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt;&lt;string&gt;https://www.example.com/image.512x512.jpg&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt;&lt;key&gt;metadata&lt;/key&gt; &lt;dict&gt; &lt;!-- required --&gt; &lt;key&gt;bundle-identifier&lt;/key&gt; &lt;string&gt;com.example.fooapp&lt;/string&gt; &lt;!-- optional (software only) --&gt; &lt;key&gt;bundle-version&lt;/key&gt; &lt;string&gt;1.0&lt;/string&gt; &lt;!-- required. the download kind.--&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software&lt;/string&gt; &lt;!-- optional. displayed during download; typically company name --&gt; &lt;key&gt;subtitle&lt;/key&gt; &lt;string&gt;Apple&lt;/string&gt; &lt;!-- required. the title to display during the download.--&gt; &lt;key&gt;title&lt;/key&gt; &lt;string&gt;Example Corporate App&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/array&gt;&lt;/dict&gt;&lt;/plist&gt; 最后实现二维码扫描安装app，无非是把这个plist文件的文件下载地址转成二维码，然后你用手机扫描，然后手机自动下载plist文件，ios系统分析xml文件，获取ipa包地址，然后下载-验证-等等，最后成功安装！ 技术交流群:494826724","categories":[],"tags":[{"name":"ios部署","slug":"ios部署","permalink":"https://devchao.com/tags/ios部署/"}]},{"title":"UIPopoverPresentationController解析","slug":"UIPopoverPresentationController解析","date":"2016-03-03T09:41:59.000Z","updated":"2016-09-18T08:37:15.000Z","comments":true,"path":"2016/03/03/UIPopoverPresentationController解析/","link":"","permalink":"https://devchao.com/2016/03/03/UIPopoverPresentationController解析/","excerpt":"","text":"iOS8新特性之UIPopoverPresentationController123456789101112131415161718192021222324if ([[UIDevice currentDevice].systemVersion floatValue] &lt; 8.0f) &#123; UIViewController *contVC = [[UIViewController alloc]init]; contVC.view.frame = self.view.frame; UIPopoverController *popVC = [[UIPopoverController alloc]initWithContentViewController:contVC]; if ([UIDevice currentDevice].userInterfaceIdiom == UIUserInterfaceIdiomPad) &#123; [popVC presentPopoverFromRect:_button.frame inView:self.view permittedArrowDirections:UIPopoverArrowDirectionAny animated:YES]; &#125;else&#123; [self presentViewController:contVC animated:YES completion:nil]; &#125; &#125;else&#123; UIViewController *VC = [[UIViewController alloc]init]; VC.view.frame = self.view.frame;//最大320 X 600 VC.modalPresentationStyle = UIModalPresentationPopover; VC.view.backgroundColor = [UIColor yellowColor]; UIPopoverPresentationController *popPreVC = VC.popoverPresentationController; popPreVC.sourceRect = _button.frame; popPreVC.sourceView = self.view; popPreVC.barButtonItem = [[UIBarButtonItem alloc]initWithCustomView:_button]; popPreVC.permittedArrowDirections = UIPopoverArrowDirectionAny; popPreVC.delegate = self; [self presentViewController:VC animated:YES completion:nil]; &#125; 技术交流群:494826724","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://devchao.com/tags/ios/"}]},{"title":"Sqlite3数据库加密","slug":"Sqlite3数据库加密","date":"2016-03-03T03:14:43.000Z","updated":"2016-09-18T08:36:49.000Z","comments":true,"path":"2016/03/03/Sqlite3数据库加密/","link":"","permalink":"https://devchao.com/2016/03/03/Sqlite3数据库加密/","excerpt":"","text":"sqlit3数据库加密前言：你是否正在为数据库中数据的安全性儿担忧？本节我讲一下关于数据库的加密相关的知识。 工具： FMDB sqlcipher Xcode 7.2 I.构建项目运行环境 ###导入FMDB到项目 下载FMDB，也可以去github上去clone 导入项目 在下载的目录下找到./src/fmdb 把其拖入项目中 加入sqlite依赖库libsqlite3.tbd targets&gt;build phases&gt;link bnary with Libraries点‘+’搜索libsqlite3.tbd加入到项目中 ###导入sqlcipher到项目 官方教程 sqlcipher不再依赖openssl，从官网教程这样描述 12OpenSSLOpenSSL is no longer required for building SQLCipher on iOS and OS X, as the project by default uses Apple&apos;s CommonCrypto framework for hardware-accelerated encryption. You can still build SQLCipher with other crypto providers like OpenSSL if you&apos;d prefer, or you can write your own. 说在ios和OS X 上openssl不再是编译sqlcipher所必须的库了，sqlcipher默认情况下使用苹果的硬件加速CommonCrypto框架加密。 下面我们实践一下 1.下载sqlcipher，也可以去github上去clone 2.把sqlcipher.xcodeproj加入到你的项目中,注意不要选择copy items if needed 3.配置Target Dependencies 和 Link Binary With Libraries PS:移除Link Binary With Libraries中的libsqlite3.dylib和其他的SQLite framework，否则会报错：’duplicate symbol errors‘ 配置编译设置 在Header Search Paths中添加sqlcipher中的src文件路径我的是../sqlcipher/src Other C Flags中添加-DSQLITE_HAS_CODEC II.应用sqlcipher实现数据库的加密解密在Viewcontroller中引入 FMDatabase.h FMDatabaseAdditions.h #define docPath NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0] 1.创建未加密数据库 12345678910111213141516171819202122 FMDatabase *db = [FMDatabase databaseWithPath:[docPath stringByAppendingPathComponent:@&quot;unencryptDB.db3&quot;]]; [db open] // 创建未加密数据库 NSString *sql = @&quot;create table if not exists polit(id integer, userName text, password text)&quot;; BOOL result = [db executeUpdate:sql]; if (result) &#123; NSLog(@&quot;create table polit succsss...&quot;); &#125;else&#123; NSLog(@&quot;create table polit error...&quot;); &#125; // 插入数据 NSString *insertSql = @&quot;insert into polit(id, userName, password) values(1,&apos;张三&apos;,&apos;zhangsan&apos;)&quot;; BOOL insetResult = [db executeUpdate:insertSql]; if (insetResult) &#123; NSLog(@&quot;insert into polit a value success....&quot;); &#125;else&#123; NSLog(@&quot;insert into polit a value error...&quot;); &#125; 2.- 使用SQLCipher加密已存在的数据库unencryptDB.db3 SQLCipher提供了sqlcipher_export()函数，该函数可以方便的对一个普通数据库导入到SQLCipher加密加密的数据库中，操作方式如下: 数据库端操作 1234$ ./sqlcipher plaintext.db sqlite&gt; ATTACH DATABASE &apos;encrypted.db&apos; AS encrypted KEY &apos;testkey&apos;; sqlite&gt; SELECT sqlcipher_export(&apos;encrypted&apos;); sqlite&gt; DETACH DATABASE encrypted; iOS端操作 1234567891011FMDatabase *db = [FMDatabase databaseWithPath:[docPath stringByAppendingPathComponent:@&quot;unencryptDB.db3&quot;]]; [db open] NSString *encryptDBsql =[NSString stringWithFormat:@&quot;ATTACH DATABASE &apos;%@&apos; AS encrypted KEY &apos;zhangyachao&apos;;&quot; &quot;SELECT sqlcipher_export(&apos;encrypted&apos;);&quot; &quot;DETACH DATABASE encrypted;&quot;,[docPath stringByAppendingPathComponent:@&quot;encryptDB.db3&quot;]]; BOOL sql3 = [db executeStatements:encryptDBsql]; if (sql3) &#123; NSLog(@&quot;statament success...&quot;); &#125;else&#123; NSLog(@&quot;statament error....&quot;); &#125; 3.验证数据库是否加密成功 123456789101112131415FMDatabase *db = [FMDatabase databaseWithPath:[docPath stringByAppendingPathComponent:@&quot;encryptDB.db3&quot;]]; [db open] if ([db open] &amp;&amp; [db setKey:@&quot;zhangyachao&quot;]) &#123; NSLog(@&quot;密码正确，打开加密数据库成功....&quot;); &#125;else &#123; NSLog(@&quot;密码错误，打开加密数据库失败....&quot;); &#125; NSString *tableCountSql = @&quot;select count(*) from SQLITE_MASTER where sql is not null and type=&apos;table&apos;&quot;; NSInteger count = [db intForQuery:tableCountSql]; if (count &gt; 0) &#123; NSLog(@&quot;数据库中表的个数为%ld&quot;,count); &#125;else&#123; NSLog(@&quot;查询表个数错误！&quot;); &#125; 4.解除使用SQLCipher加密的数据库密码 数据库端操作 12345$ ./sqlcipher encrypted.db sqlite&gt; PRAGMA key = &apos;testkey&apos;; sqlite&gt; ATTACH DATABASE &apos;plaintext.db&apos; AS plaintext KEY &apos;&apos;; -- empty key will disable encryption sqlite&gt; SELECT sqlcipher_export(&apos;plaintext&apos;); sqlite&gt; DETACH DATABASE plaintext; iOS端操作 123456789101112FMDatabase *db = [FMDatabase databaseWithPath:[docPath stringByAppendingPathComponent:@&quot;encryptDB.db3&quot;]];[db open]NSString *otherUnencryptDBsql =[NSString stringWithFormat:@&quot;PRAGMA key = &apos;zhangyachao&apos;;&quot; &quot;ATTACH DATABASE &apos;%@&apos; AS otherUnencryptDB KEY &apos;&apos;;&quot; &quot;SELECT sqlcipher_export(&apos;otherUnencryptDB&apos;);&quot; &quot;DETACH DATABASE encrypted;&quot;,[docPath stringByAppendingPathComponent:@&quot;otherUnencryptDB.db3&quot;]]; BOOL otherUnencryptDBRes = [db executeStatements:otherUnencryptDBsql]; if (otherUnencryptDBRes) &#123; NSLog(@&quot;数据库解密成功...&quot;); &#125;else&#123; NSLog(@&quot;数据客解密失败...&quot;); &#125; SQLCipher是一个使用方便，灵活性高的数据库加密工具。最后奉上本人的加解密代码Sqlit3附加数据库 本文部分参考了王中周的技术博客 技术交流群:494826724","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"iOS9网络请求之NSURLSession","slug":"iOS9网络请求之NSURLSession","date":"2016-03-02T05:43:33.000Z","updated":"2016-09-18T08:34:35.000Z","comments":true,"path":"2016/03/02/iOS9网络请求之NSURLSession/","link":"","permalink":"https://devchao.com/2016/03/02/iOS9网络请求之NSURLSession/","excerpt":"","text":"NSURL NSURLConnection NSURLRequest NSMutbaleURLRequest NSURLSession NSURLSessionDataTask 用法总结 1.NSURLSessionDataTask 1234567891011// http://yachaocn.com/ NSURLRequest *theRequest=[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://yachaocn.com/&quot;] cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:10.0]; NSURLSession *section = [NSURLSession sharedSession]; NSURLSessionDataTask *dataTaskSection = [section dataTaskWithRequest:theRequest completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;// text/plain [self.webView loadData:data MIMEType:@&quot;text/html&quot; textEncodingName:@&quot;utf-8&quot; baseURL:nil]; NSLog(@&quot;success...&quot;); &#125;]; [dataTaskSection resume]; 2.NSURLSessionUploadTask 12345678910111213NSURL *URL = [NSURL URLWithString:@&quot;http://example.com/upload&quot;]; NSURLRequest *request = [NSURLRequest requestWithURL:URL]; NSData *data = ...; NSURLSession *session = [NSURLSession sharedSession]; NSURLSessionUploadTask *uploadTask = [session uploadTaskWithRequest:request fromData:data completionHandler: ^(NSData *data, NSURLResponse *response, NSError *error) &#123; // ... &#125;]; [uploadTask resume]; 3.NSURLSessionDownloadTask 12345678910111213141516171819202122232425262728293031NSURL *URL = [NSURL URLWithString:@&quot;http://b.hiphotos.baidu.com/image/w%3D2048/sign=6be5fc5f718da9774e2f812b8469f919/8b13632762d0f703b0faaab00afa513d2697c515.jpg&quot;]; NSURLRequest *request = [NSURLRequest requestWithURL:URL]; NSURLSession *session = [NSURLSession sharedSession]; NSURLSessionDownloadTask *downloadTask = [session downloadTaskWithRequest:request completionHandler: ^(NSURL *location, NSURLResponse *response, NSError *error) &#123; [self showResponseCode:response]; // 输出下载文件原来的存放目录 NSLog(@&quot;%@&quot;, location); // 设置文件的存放目标路径 NSString *documentsPath = [self getDocumentsPath]; NSURL *documentsDirectoryURL = [NSURL fileURLWithPath:documentsPath]; NSURL *fileURL = [documentsDirectoryURL URLByAppendingPathComponent:[[response URL] lastPathComponent]]; // 如果该路径下文件已经存在，就要先将其移除，在移动文件 NSFileManager *fileManager = [NSFileManager defaultManager]; if ([fileManager fileExistsAtPath:[fileURL path] isDirectory:NULL]) &#123; [fileManager removeItemAtURL:fileURL error:NULL]; &#125; [fileManager moveItemAtURL:location toURL:fileURL error:NULL]; // 在webView中加载图片文件 NSURLRequest *showImage_request = [NSURLRequest requestWithURL:fileURL]; [self.webView loadRequest:showImage_request]; [self.spinner stopAnimating]; &#125;]; [downloadTask resume]; 4.NSURLConnection在ios9被弃用,NSURLSessionDataTask断电续传+NSMutbaleURLRequest 12345678910111213141516171819202122232425 NSString *params = @&quot;xqsort=5&amp;jcsort=3&amp;chaxun=查询空闲教室&quot;; NSData *bodyData = [params dataUsingEncoding:NSUTF8StringEncoding]; NSMutableURLRequest *mutURlRequest = [[NSMutableURLRequest alloc]init];// [mutURlRequest setValue:cookie forHTTPHeaderField:@&quot;Cookie&quot;]; [mutURlRequest setURL:[NSURL URLWithString:@&quot;http://192.168.10.220:18080/data/1.jsp&quot;]]; [mutURlRequest setHTTPMethod:@&quot;POST&quot;]; [mutURlRequest setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; [mutURlRequest setHTTPBody:bodyData]; NSURLSession *session = [NSURLSession sharedSession]; // 断点续传用// NSURLSessionConfiguration *sessionConfig = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:@&quot;任意写&quot;];// NSURLSession *session = [NSURLSession sessionWithConfiguration:sessionConfig delegate:self delegateQueue:[NSOperationQueue mainQueue]];// 继续下载// [session downloadTaskWithResumeData:&lt;#(nonnull NSData *)#&gt;]; NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:mutURlRequest completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; &#125;];// 开始下载 [dataTask resume];// 暂停下载// [dataTask suspend]; 技术交流群:494826724","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://devchao.com/tags/ios/"}]},{"title":"关于HTTP请求的HTTPHeaderField的Content-Type的浅析","slug":"关于HTTP请求的HTTPHeaderField的Content-Type的浅析","date":"2016-03-01T07:44:36.000Z","updated":"2016-09-18T08:32:15.000Z","comments":true,"path":"2016/03/01/关于HTTP请求的HTTPHeaderField的Content-Type的浅析/","link":"","permalink":"https://devchao.com/2016/03/01/关于HTTP请求的HTTPHeaderField的Content-Type的浅析/","excerpt":"","text":"关于HTTP请求的HTTPHeaderField的Content-Type的浅析常识： ContentType 内容类型，属性指定响应的 HTTP内容类型。如果未指定 ContentType，默认为TEXT/HTML。一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些Asp网页点击的结果却是下载到的一个文件或一张图片的原因。 MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式 content-type: 编码属性此属性指定将数据回发到服务器时浏览器使用的编码类型。 application/x-www-form-urlencoded： 说明窗体数据被编码为名称/值对。这是标准的编码格式。 multipart/form-data： 窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分 text/plain： 窗体数据以纯文本形式进行编码，其中不含任何控件或格式字符。 Content-Type是返回消息中非常重要的内容，表示后面的文档属于什么MIME类型。MIME定义在RFC-2046 MIME Part 2: Media Types, Content-Type: [type]/[subtype]; parameter。例如最常见的就是text/html，它的意思是说返回的内容是文本类型，这个文本又是HTML格式的。原则上浏览器会根据Content-Type来决定如何显示返回的消息体内容。 type有下面的形式: Text：用于标准化地表示的文本信息，文本消息可以是多种字符集和或者多种格式的； Multipart：用于连接消息体的多个部分构成一个消息，这些部分可以是不同类型的数据； Application：用于传输应用程序数据或者二进制数据； Message：用于包装一个E-mail消息； Image：用于传输静态图片数据； Audio：用于传输音频或者音声数据； Video：用于传输动态影像数据，可以是与音频编辑在一起的视频数据格式。 常见的MIME类型(通用型)： 超文本标记语言文本 .html text/html xml文档 .xml text/xml XHTML文档 .xhtml application/xhtml+xml 普通文本 .txt text/plain RTF文本 .rtf application/rtf PDF文档 .pdf application/pdf Microsoft Word文件 .word application/msword PNG图像 .png image/png GIF图形 .gif image/gif JPEG图形 .jpeg,.jpg image/jpeg au声音文件 .au audio/basic MIDI音乐文件 mid,.midi audio/midi,audio/x-midi RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio MPEG文件 .mpg,.mpeg video/mpeg AVI文件 .avi video/x-msvideo GZIP文件 .gz application/x-gzip TAR文件 .tar application/x-tar 任意的二进制数据 application/octet-stream 在Form元素的语法中: form的enctype属性为编码方式，常用有两种：application/x-www-form-urlencoded和multipart/form-data，默认为application/x-www-form-urlencoded。 当action为get时候，浏览器用x-www-form-urlencoded的编码方式把form数据转换成一个字串（name1=value1&amp;name2=value2…），然后把这个字串append到url后面，用?分割，加载这个新的url。 当action为post时候，浏览器把form数据封装到http body中，然后发送到server。 如果没有type=file的控件，用默认的application/x-www-form-urlencoded就可以了。 但是如果有type=file的话，就要用到multipart/form-data了。 浏览器会把整个表单以控件为单位分割，并为每个部分加上Content-Disposition(form-data或者file),Content-Type(默认为text/plain),name(控件name)等信息，并加上分割符(boundary)。技术交流群:494826724","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://devchao.com/tags/ios/"}]},{"title":"Xcode7 网络请求报错","slug":"Xcode7-网络请求报错","date":"2016-02-29T01:07:33.000Z","updated":"2016-09-18T08:37:30.000Z","comments":true,"path":"2016/02/29/Xcode7-网络请求报错/","link":"","permalink":"https://devchao.com/2016/02/29/Xcode7-网络请求报错/","excerpt":"","text":"Xcode7 网络请求报错：The resource could not be loaded because the App Transport Security policy requires the use of a sec问题：iOS9引入了新特性App Transport Security (ATS)。详情：App Transport Security (ATS) 新特性要求App内访问的网络必须使用HTTPS协议。但是现在公司的项目使用的是HTTP协议，使用私有加密方式保证数据安全。现在也不能马上改成HTTPS协议传输。 解决方案： 在Info.plist文件中添加”App Transport SecuritySettings”, Type为”Dictionary”,再添加”Allow Arbitray Loads”, Type 为”Boolean”，“Value”为“YES”即可。技术交流群:494826724","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://devchao.com/tags/ios/"}]},{"title":"第一个随笔","slug":"第一个随笔","date":"2016-02-24T09:20:14.000Z","updated":"2016-02-24T09:20:56.000Z","comments":true,"path":"2016/02/24/第一个随笔/","link":"","permalink":"https://devchao.com/2016/02/24/第一个随笔/","excerpt":"","text":"祝大家新年好！！！","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://devchao.com/tags/随笔/"}]},{"title":"QLPreviewController解析","slug":"QLPreviewController解析","date":"2016-02-23T09:04:29.000Z","updated":"2016-09-18T08:36:20.000Z","comments":true,"path":"2016/02/23/QLPreviewController解析/","link":"","permalink":"https://devchao.com/2016/02/23/QLPreviewController解析/","excerpt":"","text":"QLPreviewController预览功能前言：今天有一个陌生的好友问我QLPreviewController怎么用，我并没有告诉他百度一下你就知道了，而是给他写了一个简单的例子，我相信知识贵在总结，虽然对于QLPreviewController的用法很简单，但是一些刚接触此门语言的童鞋们还是不会用，在这里就小小的总结一下吧，就算是对自己知识的一种巩固。 关于QLPreviewController能够预览的文件格式官方文档中这样描述：(看不懂的自行翻译，英语要每天练习哦) 123456789101112131415A Quick Look preview controller can display previews for the following items:iWork documentsMicrosoft Office documents (Office ‘97 and newer)Rich Text Format (RTF) documentsPDF filesImagesText files whose uniform type identifier (UTI) conforms to the public.text type (see Uniform Type Identifiers Reference)Comma-separated value (csv) files QLPreviewController主要是实现简单的文件预览功能的，比如mac里的空格键，按了之后会弹出一个预览视图一样。好下面介绍他的用法： 1.导入QuickLook.framework动态库1Target &gt; Build Phase &gt; Link Binary whith libraries点击加号搜索后加入即可 2.添加资源文件123456在这里我选择了一张pdf，和一张图片，直接拖入项目中，选择copy items if needed和create groups NSURL *fileUrl = [[NSBundle mainBundle] URLForResource:@&quot;roat&quot; withExtension:@&quot;pdf&quot;subdirectory:@&quot;&quot;]; NSURL *imageUrl = [[NSBundle mainBundle] URLForResource:@&quot;1&quot; withExtension:@&quot;png&quot;subdirectory:@&quot;&quot;]; _array = @[fileUrl,imageUrl]; 3.创建QLPreviewController对象,并触发事件，此处我选择了点击button后触发。12345678//需要导入头文件#import &lt;QuickLook/QLPreviewController.h&gt;并遵守代理QLPreviewControllerDataSource- (IBAction)preview:(id)sender &#123; QLPreviewController *ql = [[QLPreviewController alloc]init]; ql.dataSource = self; ql.currentPreviewItemIndex = 1; [self presentViewController:ql animated:YES completion:nil]; &#125; QLPreviewControllerDataSource 12345678910#pragma mark - QLViewController data source- (NSInteger)numberOfPreviewItemsInPreviewController:(QLPreviewController *)controller&#123; return 2;&#125;- (id &lt;QLPreviewItem&gt;)previewController:(QLPreviewController *)controller previewItemAtIndex:(NSInteger)index&#123; return _array[index];&#125; 具体的.m实现文件如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//// ViewController.m// QLDemo//// Created by yachaocn on 16/2/23.// Copyright © 2016年 NavchinaMacBook. All rights reserved.//#import &quot;ViewController.h&quot;#import &lt;QuickLook/QLPreviewController.h&gt;@interface ViewController () &lt;QLPreviewControllerDataSource&gt;@property(nonatomic,strong) NSArray *array;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. NSURL *fileUrl = [[NSBundle mainBundle] URLForResource:@&quot;roat&quot; withExtension:@&quot;pdf&quot;subdirectory:@&quot;&quot;]; NSURL *imageUrl = [[NSBundle mainBundle] URLForResource:@&quot;1&quot; withExtension:@&quot;png&quot;subdirectory:@&quot;&quot;]; _array = @[fileUrl,imageUrl]; &#125;- (IBAction)preview:(id)sender &#123; QLPreviewController *ql = [[QLPreviewController alloc]init]; ql.dataSource = self; ql.currentPreviewItemIndex = 1; [self presentViewController:ql animated:YES completion:nil]; &#125;#pragma mark - QLViewController data source- (NSInteger)numberOfPreviewItemsInPreviewController:(QLPreviewController *)controller&#123; return 2;&#125;- (id &lt;QLPreviewItem&gt;)previewController:(QLPreviewController *)controller previewItemAtIndex:(NSInteger)index&#123; return _array[index];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end 试一下效果吧，棒棒哒！！！ 技术交流群:494826724","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"NSEnum-struct定义","slug":"NSEnum-struct定义","date":"2016-02-22T03:52:08.000Z","updated":"2016-09-18T08:36:04.000Z","comments":true,"path":"2016/02/22/NSEnum-struct定义/","link":"","permalink":"https://devchao.com/2016/02/22/NSEnum-struct定义/","excerpt":"","text":"枚举值-结构体的定义总结结构体定义12345678typedef struct Books&#123; NSString *title; NSString *author; NSString *subject; int book_id;&#125; Book; 枚举值得定义方式1. typedef enum {...}别名； 12345typedef enum &#123; Circular, Square, Oval&#125;DestType; 方式2.定义类型：typedef enum 别名 : 类型名 别名；定义枚举值：enum 别名 : 类型名{...}; 123456typedef enum HoseType : NSInteger HoseType;enum HoseType : NSInteger&#123; A, B, C&#125;; 方式3. 1234typedef NS_ENUM(NSInteger , WorldType) &#123; Earth, Sun&#125;; 上述由下面改写而来 123456typedef enum WorldType : NSInterger WorldType;enum WorldType : NSInterger&#123; A, B, C&#125;; 方式5. 123456typedef NS_OPTIONS(NSInteger, PhoneType) &#123; iPhone4 = 0, iPhone5 = 1 &lt;&lt; 0, iPhone6 = 1 &lt;&lt; 1, iPhone6s = 1 &lt;&lt; 2,&#125;; 从枚举定义来看，NS_ENUM和NS_OPTIONS本质是一样的，仅仅从字面上来区分其用途。NS_ENUM是通用情况，NS_OPTIONS一般用来定义具有位移操作或特点的情况（bitmask)。 技术交流群:494826724","categories":[],"tags":[]},{"title":"The dynamic library plug-in","slug":"The dynamic library plug-in","date":"2016-02-19T07:06:30.000Z","updated":"2016-09-18T08:37:01.000Z","comments":true,"path":"2016/02/19/The dynamic library plug-in/","link":"","permalink":"https://devchao.com/2016/02/19/The dynamic library plug-in/","excerpt":"","text":"iOS动态库的构建之应用程序的插件化前言： 你有没有非常厌烦apple漫长的审核机制，有没有想要直接跳过苹果的审核，而能过更新我们的程序？那么动态库就能实现这样的功能。那么什么是库？什么是动态库呢？相反什么是动态库呢？我们如何去构建一个动态库呢？接下来如何去使用库呢？如何运用动态库实现应用程序的插件化呢？ 什么是库？ 库是共享程序代码的方式，一般分为静态库和动态库。 静态库：链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。 动态库：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。 库的形式： - 静态库的形式：.a和.framework - 动态库的形式：.dylib和.framework a与.framework有什么区别: - .a是一个纯二进制文件，.framework中除了有二进制文件之外还有资源文件。 - .a文件不能直接使用，至少要有.h文件配合，.framework文件可以直接使用。 - .a + .h + sourceFile = .framework。 - 建议用.framework. 为什么要使用静态库？ - 方便共享代码，便于合理使用。 - 实现iOS程序的模块化。可以把固定的业务模块化成静态库。 - 和别人分享你的代码库，但不想让别人看到你代码的实现。 制作静态库时的几点注意: - 1 注意理解：无论是.a静态库还.framework静态库，我们需要的都是二进制文件+.h+其它资源文件的形式，不同的是，.a本身就是二进制文件，需要我们自己配上.h和其它文件才能使用，而.framework本身已经包含了.h和其它文件，可以直接使用。 - 2 图片资源的处理：两种静态库，一般都是把图片文件单独的放在一个.bundle文件中，一般.bundle的名字和.a或.framework的名字相同。.bundle文件很好弄，新建一个文件夹，把它改名为.bundle就可以了，右键，显示包内容可以向其中添加图片资源。 - 3 category是我们实际开发项目中经常用到的，把category打成静态库是没有问题的，但是在用这个静态库的工程中，调用category中的方法时会有找不到该方法的运行时错误（selector not recognized），解决办法是：在使用静态库的工程中配置other linker flags的值为-ObjC。 - 4 如果一个静态库很复杂，需要暴露的.h比较多的话，就可以在静态库的内部创建一个.h文件（一般这个.h文件的名字和静态库的名字相同），然后把所有需要暴露出来的.h文件都集中放在这个.h文件中，而那些原本需要暴露的.h都不需要再暴露了，只需要把.h暴露出来就可以了。 在本章我们只介绍动态库，静态库放在以后章节，敬请关注 apple 开放动态库WWDC2014上发布的Xcode6 beta版有了不少更新，其中令我惊讶的一个是苹果在iOS上开放了动态库，在Xcode6 Beta版的更新文档中是这样描述的：详见官方文档https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Articles/xcode_6_0.html 1“Frameworks for iOS. iOS developers can now create dynamic frameworks. Frameworks are a collection of code and resources to encapsulate functionality that is valuable across multiple projects. Frameworks work perfectly with extensions, sharing logic that can be used by both the main application, and the bundled extensions.” framework是Cocoa/Cocoa Touch程序中使用的一种资源打包方式，可以将将代码文件、头文件、资源文件、说明文档等集中在一起，方便开发者使用，作为一名Cocoa/Cocoa Touch程序员每天都要跟各种各样的Framework打交道。Cocoa/Cocoa Touch开发框架本身提供了大量的Framework，比如Foundation.framework/UIKit.framework/AppKit.framework等。需要注意的是，这些framework无一例外都是动态库。 但残忍的是，Cocoa Touch上并不允许我们使用自己创建的framework。不过由于framework是一种优秀的资源打包方式，拥有无穷智慧的程序员们便想出了以framework的形式打包静态库的招数，因此我们平时看到的第三方发布的framework无一例外都是静态库，真正的动态库是上不了AppStore的。 WWDC2014给我的一个很大感触是苹果对iOS的开放态度：允许使用动态库、允许第三方键盘、App Extension等等，这些在之前是想都不敢想的事。 静态库在编译时和app代码链接并打进同一个二进制包中,而动态库可以在运行时手动加载，这样就可以做很多事情，比如不增大应用程序包文件大小的情况下，实现模块的插件化！支付宝就是这样的： 首页上密密麻麻的功能，而且还在增多，照这个趋势发展下去，软件包的大小将会不可想象。目前常用的解决方案是使用web页面，但用户体验和Native界面是没法比的。 设想，如果每一个功能点都是一个动态库，在用户想使用某个功能的时候让其从网络下载，然后手动加载动态库，实现功能的的插件化，就再也不用担心功能点的无限增多了，这该是件多么美好的事 软件版本实时模块升级 还在忍受苹果动辄一周，甚至更长的审核周期吗？有了动态库妈妈就再也不用担心你的软件升级了！ 如果软件中的某个功能点出现了严重的bug，或者想在其中新增功能，你的这个功能点又是通过动态库实现的，这时候你只需要在适当的时候从服务器上将新版本的动态库文件下载到本地，然后在用户重启应用的时候即可实现新功能的展现。 共享可执行文件 在其它大部分平台上，动态库都可以用于不同应用间共享，这就大大节省了内存。从目前来看，iOS仍然不允许进程间共享动态库，即iOS上的动态库只能是私有的，因为我们仍然不能将动态库文件放置在除了自身沙盒以外的其它任何地方。 不过iOS8上开放了App Extension功能，可以为一个应用创建插件，这样主app和插件之间共享动态库还是可行的 PS： 上述关于动态库在iOS平台的使用，在技术上都是可行的，但本人并没有真正尝试过做出一个上线AppStore的应用，因此并不保证按照上述方式使用动态库一定能通过苹果审核！ 创建动态库创建工程文件 在下图找到Cocoa Touch动态库的创建入口：跟随指引一步步操作即可创建一个新的动态库工程，我的工程名字叫Dylib，Xcode会同时创建一个和工程target同名的.h文件，比如我的就是Dylib.h。 向工程中添加文件接下来就可以在工程中随意添加文件了。我在其中新建了一个名为Person的测试类，提供的接口如下： 12345@interface Person : NSObject - (void)run; @end 对应的.m文件 123456789@implementation Person - (void)run &#123; NSLog(@&quot;let&apos;s run.&quot;); &#125; @end 注意需要在Dylib.h中加入#import &lt;Dylib/Person.h&gt;头文件引用，否则在别的项目中导入动态库后使用时会报framework missing submodule xxx 警告具体解决方案参见http://yachaocn.com/2016/02/18/framework%20missing%20submodule/ 设置开放的头文件 一个库里面可以后很多的代码，但是我们需要设置能够提供给外界使用的接口，可以通过Target—&gt;Build Phases—&gt;Headers来设置，如下图所示： 我们只需将希望开放的头文件放到Public列表中即可，比如我开放了Dylib.h和Person.h两个头文件，在生成的framework的Header目录下就可以看到这两个头文件, 在xcode菜单栏找到window&gt;project如下图所示：点击小箭头之后，进入framework目录，找到Build》Products》Debug-iphoneos》Dylib.framework》Headers就会看到两个开放的头文件。如图： 一切完成，Run以后就能成功生成framework文件了。注意你用真机运行后打的framework只能在真机上用，用模拟器打的framework只能在模拟器上用要想能同时在两个上面用，需要生成通用动态库如下： 生成通用动态库经过第一步我们只是创建了一个动态库文件，但是和静态库类似，该动态库并同时不支持真机和模拟器，可以通过以下步骤创建通用动态库： 创建Aggregate Target 按下图所示，在动态库工程中添加一个类型为Aggregate的target:不知道如何添加target的自行搜索不再赘述按提示一步步操作即可，我给Aggregate的Target的命名是CommonDylib。 设置Target Dependencies 按以下路径设置CommonDylib对应的Target Dependencies: 1TARGETS--&gt;CommonDylib--&gt;Build Phases--&gt;Target Dependencies 将真正的动态库Dylib Target添加到其中。 添加Run Script 按以下路径为CommonDylib添加Run Script: 1TARGETS--&gt;CommonDylib--&gt;Build Phases--&gt;Run Script 添加的脚本为： 12345678910111213141516171819202122232425262728293031# Sets the target folders and the final framework product. FMK_NAME=$&#123;PROJECT_NAME&#125; # Install dir will be the final output to the framework. # The following line create it in the root folder of the current project. INSTALL_DIR=$&#123;SRCROOT&#125;/Products/$&#123;FMK_NAME&#125;.framework # Working dir will be deleted after the framework creation. WRK_DIR=build DEVICE_DIR=$&#123;WRK_DIR&#125;/Release-iphoneos/$&#123;FMK_NAME&#125;.framework SIMULATOR_DIR=$&#123;WRK_DIR&#125;/Release-iphonesimulator/$&#123;FMK_NAME&#125;.framework # -configuration $&#123;CONFIGURATION&#125; # Clean and Building both architectures. xcodebuild -configuration &quot;Release&quot; -target &quot;$&#123;FMK_NAME&#125;&quot; -sdk iphoneos clean build xcodebuild -configuration &quot;Release&quot; -target &quot;$&#123;FMK_NAME&#125;&quot; -sdk iphonesimulator clean build # Cleaning the oldest. if [ -d &quot;$&#123;INSTALL_DIR&#125;&quot; ] then rm -rf &quot;$&#123;INSTALL_DIR&#125;&quot; fi mkdir -p &quot;$&#123;INSTALL_DIR&#125;&quot; cp -R &quot;$&#123;DEVICE_DIR&#125;/&quot; &quot;$&#123;INSTALL_DIR&#125;/&quot; # Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product. lipo -create &quot;$&#123;DEVICE_DIR&#125;/$&#123;FMK_NAME&#125;&quot; &quot;$&#123;SIMULATOR_DIR&#125;/$&#123;FMK_NAME&#125;&quot; -output &quot;$&#123;INSTALL_DIR&#125;/$&#123;FMK_NAME&#125;&quot; rm -r &quot;$&#123;WRK_DIR&#125;&quot; 添加以后的效果如图所示: 该脚本是我根据一篇文章中介绍的脚本改写的，感谢原文作者。 脚本的主要功能是： 1.分别编译生成真机和模拟器使用的framework； 2.使用lipo命令将其合并成一个通用framework； 3.最后将生成的通用framework放置在工程根目录下新建的Products目录下。 如果你第一次用真机run跑出的Dylib.framework，那么这次用模拟器对CommonDylib target执行run操作，然后就在你项目根目录下&gt;Products文件下生成一个如图所示的通用framework文件了。 使用动态库添加动态库到工程文件 经过以上步骤的努力，生成了最终需要的framework文件，为了演示动态库的使用，新建了一个名为FrameworkDemo的工程。通过以下方式将刚生成的framework添加到工程中： 1Targets--&gt;Build Phases--&gt;Link Binary With Libraries 同时设置将framework作为资源文件拷贝到Bundle中： 1Targets--&gt;Build Phases--&gt;Copy Bundle Resources 如图所示： 仅仅这样做是不够的，还需要为动态库添加链接依赖。 自动链接动态库 添加完动态库后，如果希望动态库在软件启动时自动链接，可以通过以下方式设置动态库依赖路径 1Targets--&gt;Build Setting--&gt;Linking--&gt;Runpath Search Paths 由于向工程中添加动态库时，将动态库设置了Copy Bundle Resources，因此就可以将Runpath Search Paths路径依赖设置为main bundle，即沙盒中的FrameworkDemo.app目录，向Runpath Search Paths中添加下述内容： 1@executable_path/ 如图所示：其中的@executable_path/表示可执行文件所在路径，即沙盒中的.app目录，注意不要漏掉最后的/。 如果你将动态库放到了沙盒中的其他目录，只需要添加对应路径的依赖就可以了。 需要的时候链接动态库 动态库的另一个重要特性就是即插即用性，我们可以选择在需要的时候再加载动态库。 更改设置 如果不希望在软件一启动就加载动态库，需要将 1Targets--&gt;Build Phases--&gt;Link Binary With Libraries 中Dylib.framework对应的Status由默认的Required改成Optional；或者更干脆的，将Dylib.framework从Link Binary With Libraries列表中删除即可。 使用动态库使用dlopen加载动态库 以Dylib.framework为例，动态库中真正的可执行代码为Dylib.framework/Dylib文件，因此使用dlopen时如果仅仅指定加载动态库的路径为Dylib.framework是没法成功加载的。dlopen用到了c库需要引入#include &lt;dlfcn.h&gt; 示例代码如下 1234567891011121314151617181920212223242526272829303132333435363738#import &quot;ViewController.h&quot;#import &lt;Dylib/Dylib.h&gt;#import &lt;Dylib/Person.h&gt;#include &lt;dlfcn.h&gt;static void *libHandle = NULL;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. NSString *documentsPath = [NSString stringWithFormat:@&quot;%@/Documents/Dylib.framework/Dylib&quot;,NSHomeDirectory()]; [self dlopenLoadDylibWithPath:documentsPath]; &#125;- (void)dlopenLoadDylibWithPath:(NSString *)path&#123; libHandle = NULL; libHandle = dlopen([path cStringUsingEncoding:NSUTF8StringEncoding], RTLD_NOW); if (libHandle == NULL) &#123; char *error = dlerror(); NSLog(@&quot;dlopen error: %s&quot;, error); &#125; else &#123; NSLog(@&quot;dlopen load framework success.&quot;); Class rootClass = NSClassFromString(@&quot;Person&quot;); if (rootClass) &#123; id object = [[rootClass alloc] init]; [(Person *)object run]; &#125; &#125;&#125; 以dlopen方式使用动态库不知道是否能通过苹果审核。 使用NSBundle加载动态库 也可以使用NSBundle来加载动态库，实现代码如下： 123456789101112131415161718- (IBAction)onBundleLoadAtPathAction1:(id)sender &#123; NSString *documentsPath = [NSString stringWithFormat:@&quot;%@/Documents/Dylib.framework&quot;,NSHomeDirectory()]; [self bundleLoadDylibWithPath:documentsPath]; &#125; - (void)bundleLoadDylibWithPath:(NSString *)path &#123; _libPath = path; NSError *err = nil; NSBundle *bundle = [NSBundle bundleWithPath:path]; if ([bundle loadAndReturnError:&amp;err]) &#123; NSLog(@&quot;bundle load framework success.&quot;); &#125; else &#123; NSLog(@&quot;bundle load framework err:%@&quot;,err); &#125; &#125; 使用动态库中代码 通过上述任一一种方式加载的动态库后，就可以使用动态库中的代码文件了，以Dylib.framework中的Person类的使用为例： 12345Class rootClass = NSClassFromString(@&quot;Person&quot;); if (rootClass) &#123; id object = [[rootClass alloc] init]; [(Person *)object run]; &#125; 注意，如果直接通过下属方式初始化Person类是不成功的 1234Person *object = [[Person alloc] init]; if (object) &#123; [object run]; &#125; 监测动态库的加载和移除 我们可以通过下述方式，为动态库的加载和移除添加监听回调 12345+ (void)load &#123; _dyld_register_func_for_add_image(&amp;image_added); _dyld_register_func_for_remove_image(&amp;image_removed); &#125; github上有一个完整的示例代码。 从这里看出，原来就算空白工程软件启动的时候也会加载多达一百二十多个动态库，如果这些都是静态库，那该有多可怕！！ 为了证明动态库的插件化，我做了一个例子：在程序启动后连接Document目录下的动态库Dylib.framework 把基础框架的动态库（只有Person.h和.m文件，和其中的run接口的Dylib.framework）加入到项目中，然后重新打包一个动态库放在沙河下的Document目录下，其中新建了一个，Desk.h和.m文件 .h 123@interface Desk : NSObject-(void)sayName;@end .m 1234-(void)sayName&#123; NSLog(@&quot;my name is desk... over&quot;);&#125; 然后在Person.m文件中的run接口中加入如下代码： 12345678- (void)run&#123; NSLog(@&quot;let&apos;s run.&quot;); Desk *desk = [[Desk alloc]init]; desk.deskName = @&quot;desk&quot;; [desk sayName]; &#125; 然后用dlopen方法加载沙河下的Document目录里的动态库Dylib.framework. 运行后结果为如下 122016-02-19 14:20:40.582 FrameworkDemo[1382:42391] let&apos;s run.2016-02-19 14:20:40.582 FrameworkDemo[1382:42391] my name is desk... over 由此可见 我们添加到项目中的Dylib.framework并没有被连接到项目中，也没有被执行，而是加载了Document目录下的Dylib.framework 我们添加到项目中的Dylib.framework只是个框架，提供了一个对外的接口，在预编译时不至于我们的程序报错。 真正运行时连接的动态库并不是我们项目中添加的，而是Documnet目录下的Dylib.framework动态库 我们可以单独把Dylib.framework摘出来，在其基础上扩展，添加各式各样的功能。 然后我们就可以写一个加载动态库的基础框架app然后提交app审核通过后，我们就可以在程序运行的时候从服务器检查动态库是否有更新（新的功能、界面等），如果有更新直接从服务其上面下载framework替换本地的Document目录下的动态库，然后重启系统，就能跳过app store的漫长的审核，而使程序快速的更新。 最后附上本文所用到的代码【下载代码】 本文参考自王中周的技术博客致谢！ 技术交流群:494826724","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://devchao.com/tags/ios/"}]},{"title":"framework missing submodule","slug":"framework missing submodule","date":"2016-02-18T02:26:36.000Z","updated":"2016-09-18T08:33:25.000Z","comments":true,"path":"2016/02/18/framework missing submodule/","link":"","permalink":"https://devchao.com/2016/02/18/framework missing submodule/","excerpt":"","text":"framework missing submodule xxx 警告从xcode6开始，iOS可以直接创建生成framework了 如： 创建 framework 项目，TFKit.framework 则 会自动生成TFKit.h 然后我们再添加一些自已的类,并对外提供 TFA.h,TFB.h 那么需要先在 TFKit.h 里面 123#import &lt;TFKit/TFA.h&gt;#import &lt;TFKit/TFB.h&gt; 最后在build 生成 TFKit.framework使用时， 直接使用 1#import &lt;TFKit/TFKit.h&gt; 即可 技术交流群:494826724","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://devchao.com/tags/ios/"}]},{"title":"Missing iOS Distribution signing identity","slug":"Missing iOS Distribution signing identity","date":"2016-02-16T09:16:31.000Z","updated":"2016-09-18T08:35:54.000Z","comments":true,"path":"2016/02/16/Missing iOS Distribution signing identity/","link":"","permalink":"https://devchao.com/2016/02/16/Missing iOS Distribution signing identity/","excerpt":"","text":"此证书的签发者无效Missing iOS Distribution signing identity问题解决今天准备打包ipa，结果Xcode报以下错误： 查看证书后发现Develop证书和Distribution证书都提示：此证书的签发者无效。 问题原因： Apple Worldwide Developer Relations Certification Authority证书过期了。AppleWWDRCA证书实际上就是对iOS证书（即Develop证书和Distribution证书）的授权认证，其公钥用于解密认证证书的可靠性。 iOS以及Mac OS X系统（在安装Xcode时）将自动安装AppleWWDRCA.cer(Apple Worldwide Developer Relations Certification Authority)这个中间证书（Intermediate Certificates）。 解决办法： 下载最新的AppleWWDRCA证书。 点击下载 打开钥匙串，选择登录，然后选择下面的证书 选择桌面左上角的显示→显示已过期的证书。 这时候你会发现一个过期的“WWDR Certificate”（Apple Worldwide Developer Relations Certification Authority），删除它。特别注意：有的在系统那一栏也有这个过期的“WWDR Certificate”，也一并删除它，没有就不作处理。 再回头点击Develop证书和Distribution证书，不出意外他们都变成“此证书有效”了。 摘录自http://blog.csdn.net/iosHot 技术交流群:494826724","categories":[],"tags":[]},{"title":"iOS_7添加pch全局引用文件","slug":"iOS-7添加pch全局引用文件","date":"2016-01-30T01:29:13.000Z","updated":"2016-09-18T08:33:48.000Z","comments":true,"path":"2016/01/30/iOS-7添加pch全局引用文件/","link":"","permalink":"https://devchao.com/2016/01/30/iOS-7添加pch全局引用文件/","excerpt":"","text":"##xcode 7 添加pch文件 1.command+N选择Other》PCH 2.在target》build setting 中搜索 prefix header 3.双击后面空白，把你刚刚创建的pch文件拖进来，会自动填入你的pch文件的本地绝对路径，编译》success 4.恭喜你 技术交流群:494826724","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://devchao.com/tags/ios/"}]},{"title":"ios开发问题解决kcfstreamnetworkservicetypevoip被弃用","slug":"iOS开发问题解决kcfstreamnetworkservicetypevoip被弃用","date":"2016-01-28T03:46:35.000Z","updated":"2016-09-18T08:34:43.000Z","comments":true,"path":"2016/01/28/iOS开发问题解决kcfstreamnetworkservicetypevoip被弃用/","link":"","permalink":"https://devchao.com/2016/01/28/iOS开发问题解决kcfstreamnetworkservicetypevoip被弃用/","excerpt":"","text":"##ios开发问题解决kCFStreamNetworkServiceTypeVoIP’ is deprecated in iOS9xcode提出警告：kCFStreamNetworkServiceTypeVoIP&#39; is deprecated: first deprecated in iOS 9.0 - use PushKit for VoIP control purposes 解决办法： 导入import 将kCFStreamNetworkServiceTypeVoIP 改为PKPushTypeVoIP 技术交流群:494826724","categories":[],"tags":[]},{"title":"便捷生成二维码条形码","slug":"便捷生成二维码条形码","date":"2016-01-19T09:15:44.000Z","updated":"2017-05-20T05:15:51.000Z","comments":true,"path":"2016/01/19/便捷生成二维码条形码/","link":"","permalink":"https://devchao.com/2016/01/19/便捷生成二维码条形码/","excerpt":"","text":"便捷生成二维码条形码 - by yachaocn 前言先前我找到了一个生成二维码的c语言库，感觉生成二维码非常的简单，后来我在官方文档里找到了，更便捷的生成方法，在这里奉献给各位大神，当然了–我叫雷锋。 参考https://developer.apple.com/library/mac/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html 使用方法直接将下面的方法复制到你项目.m文件中，直接调用即可。 生成二维码： 12345678910111213141516171819202122//生成二维码// 参考文档// https://developer.apple.com/library/mac/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html- (UIImage *)generateQRCode:(NSString *)code width:(CGFloat)width height:(CGFloat)height &#123; // 生成二维码图片 CIImage *qrcodeImage; NSData *data = [_code dataUsingEncoding:NSISOLatin1StringEncoding allowLossyConversion:false]; CIFilter *filter = [CIFilter filterWithName:@&quot;CIQRCodeGenerator&quot;]; [filter setValue:data forKey:@&quot;inputMessage&quot;]; [filter setValue:@&quot;H&quot; forKey:@&quot;inputCorrectionLevel&quot;]; qrcodeImage = [filter outputImage]; // 消除模糊 CGFloat scaleX = width / qrcodeImage.extent.size.width; // extent 返回图片的frame CGFloat scaleY = height / qrcodeImage.extent.size.height; CIImage *transformedImage = [qrcodeImage imageByApplyingTransform:CGAffineTransformScale(CGAffineTransformIdentity, scaleX, scaleY)]; return [UIImage imageWithCIImage:transformedImage];&#125; 生成条形码： 1234567891011121314151617//生成条形码- (UIImage *)generateBarCode:(NSString *)code width:(CGFloat)width height:(CGFloat)height &#123; // 生成二维码图片 CIImage *barcodeImage; NSData *data = [_code dataUsingEncoding:NSISOLatin1StringEncoding allowLossyConversion:false]; CIFilter *filter = [CIFilter filterWithName:@&quot;CICode128BarcodeGenerator&quot;]; [filter setValue:data forKey:@&quot;inputMessage&quot;]; barcodeImage = [filter outputImage]; // 消除模糊 CGFloat scaleX = width / barcodeImage.extent.size.width; // extent 返回图片的frame CGFloat scaleY = height / barcodeImage.extent.size.height; CIImage *transformedImage = [barcodeImage imageByApplyingTransform:CGAffineTransformScale(CGAffineTransformIdentity, scaleX, scaleY)]; return [UIImage imageWithCIImage:transformedImage];&#125; 技术交流群:494826724","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"iOS生成二维码","slug":"iOS生成二维码","date":"2016-01-08T03:19:22.000Z","updated":"2017-03-23T07:02:27.000Z","comments":true,"path":"2016/01/08/iOS生成二维码/","link":"","permalink":"https://devchao.com/2016/01/08/iOS生成二维码/","excerpt":"","text":"#ios生成二维码 1.引入libqrencode 2.导入QRCodeGenerator.h、QRCodeGenerator.m 源码如下： QRCodeGenerator.h 12345678#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;@interface QRCodeGenerator : NSObject+ (UIImage *)qrImageForString:(NSString *)string imageSize:(CGFloat)size;@end QRCodeGenerator.m 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//// QR Code Generator - generates UIImage from NSString//// Copyright (C) 2012 http://moqod.com Andrew Kopanev &lt;andrew@moqod.com&gt;//// Permission is hereby granted, free of charge, to any person obtaining a copy // of this software and associated documentation files (the &quot;Software&quot;), to deal // in the Software without restriction, including without limitation the rights // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies // of the Software, and to permit persons to whom the Software is furnished to do so, // subject to the following conditions://// The above copyright notice and this permission notice shall be included in all // copies or substantial portions of the Software.//// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR // PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER // DEALINGS IN THE SOFTWARE.//#import &quot;QRCodeGenerator.h&quot;#import &quot;qrencode.h&quot;enum &#123; qr_margin = 3&#125;;@implementation QRCodeGenerator+ (void)drawQRCode:(QRcode *)code context:(CGContextRef)ctx size:(CGFloat)size &#123; unsigned char *data = 0; int width; data = code-&gt;data; width = code-&gt;width; float zoom = (double)size / (code-&gt;width + 2.0 * qr_margin); CGRect rectDraw = CGRectMake(0, 0, zoom, zoom); // draw CGContextSetFillColor(ctx, CGColorGetComponents([UIColor blackColor].CGColor)); for(int i = 0; i &lt; width; ++i) &#123; for(int j = 0; j &lt; width; ++j) &#123; if(*data &amp; 1) &#123; rectDraw.origin = CGPointMake((j + qr_margin) * zoom,(i + qr_margin) * zoom); CGContextAddRect(ctx, rectDraw); &#125; ++data; &#125; &#125; CGContextFillPath(ctx);&#125;+ (UIImage *)qrImageForString:(NSString *)string imageSize:(CGFloat)size &#123; if (![string length]) &#123; return nil; &#125; QRcode *code = QRcode_encodeString([string UTF8String], 0, QR_ECLEVEL_L, QR_MODE_8, 1); if (!code) &#123; return nil; &#125; // create context CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); CGContextRef ctx = CGBitmapContextCreate(0, size, size, 8, size * 4, colorSpace, kCGImageAlphaPremultipliedLast); CGAffineTransform translateTransform = CGAffineTransformMakeTranslation(0, -size); CGAffineTransform scaleTransform = CGAffineTransformMakeScale(1, -1); CGContextConcatCTM(ctx, CGAffineTransformConcat(translateTransform, scaleTransform)); // draw QR on this context [QRCodeGenerator drawQRCode:code context:ctx size:size]; // get image CGImageRef qrCGImage = CGBitmapContextCreateImage(ctx); UIImage * qrImage = [UIImage imageWithCGImage:qrCGImage]; // some releases CGContextRelease(ctx); CGImageRelease(qrCGImage); CGColorSpaceRelease(colorSpace); QRcode_free(code); return qrImage;&#125;@end 3.实现代码如下 123456789 - (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UIImage *q = [QRCodeGenerator qrImageForString:@&quot;http://yachaocn.com&quot; imageSize:400]; UIImageView *view = [[UIImageView alloc]initWithImage:q]; view.frame = CGRectMake(100, 100, 400, 400); [self.view addSubview:view]; &#125; 附博主代码 技术交流群:494826724","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"获取UUID并存储到keychain中","slug":"获取UUID并存储到keychain中","date":"2016-01-05T02:29:08.000Z","updated":"2017-03-23T07:02:46.000Z","comments":true,"path":"2016/01/05/获取UUID并存储到keychain中/","link":"","permalink":"https://devchao.com/2016/01/05/获取UUID并存储到keychain中/","excerpt":"","text":"UUID的获取并使用keychain存储因苹果uuid被弃用，uuid的永久不变已成为不可能，我们首先想到的是把获取的uuid存储起来，在下次打开程序时这个uuid不变，因此这里有两种方案 1.获得uuid使用NSUserDefault存储优点代码书写方便，缺点：程序卸载后，存储在NSUserDefault中的uuid被删除，再次获取的uuid和原来的不一样， 2.存储在keychain中，优点再程序卸载后uuid不变，缺点：刷机或重装系统后uuid还是会改变。 由此来看，第二种方案是最佳方案了，如果你有更好的方案请留言，下面请看实现方式官方Demo代码地址 ###下载KeychainItemWrapper代码 下载方式1:到上面的官方demo中copy一分KeychainItemWrapper.h、KeychainItemWrapper.m下载方式2:还是我给吧： KeychainItemWrapper.h 123456789101112131415161718192021222324252627#import &lt;UIKit/UIKit.h&gt;/* The KeychainItemWrapper class is an abstraction layer for the iPhone Keychain communication. It is merely a simple wrapper to provide a distinct barrier between all the idiosyncracies involved with the Keychain CF/NS container objects.*/@interface KeychainItemWrapper : NSObject&#123; NSMutableDictionary *keychainItemData; // The actual keychain item data backing store. NSMutableDictionary *genericPasswordQuery; // A placeholder for the generic keychain item query used to locate the item.&#125;@property (nonatomic, retain) NSMutableDictionary *keychainItemData;@property (nonatomic, retain) NSMutableDictionary *genericPasswordQuery;// Designated initializer.- (id)initWithAccount:(NSString *)account service:(NSString *)service accessGroup:(NSString *) accessGroup;- (id)initWithIdentifier: (NSString *)identifier accessGroup:(NSString *) accessGroup;- (void)setObject:(id)inObject forKey:(id)key;- (id)objectForKey:(id)key;// Initializes and resets the default generic keychain item data.- (void)resetKeychainItem;@end KeychainItemWrapper.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342#import &quot;KeychainItemWrapper.h&quot;#import &lt;Security/Security.h&gt;/*These are the default constants and their respective types,available for the kSecClassGenericPassword Keychain Item class:kSecAttrAccessGroup - CFStringRefkSecAttrCreationDate - CFDateRefkSecAttrModificationDate - CFDateRefkSecAttrDescription - CFStringRefkSecAttrComment - CFStringRefkSecAttrCreator - CFNumberRefkSecAttrType - CFNumberRefkSecAttrLabel - CFStringRefkSecAttrIsInvisible - CFBooleanRefkSecAttrIsNegative - CFBooleanRefkSecAttrAccount - CFStringRefkSecAttrService - CFStringRefkSecAttrGeneric - CFDataRef See the header file Security/SecItem.h for more details.*/@interface KeychainItemWrapper (PrivateMethods)/*The decision behind the following two methods (secItemFormatToDictionary and dictionaryToSecItemFormat) wasto encapsulate the transition between what the detail view controller was expecting (NSString *) and what theKeychain API expects as a validly constructed container class.*/- (NSMutableDictionary *)secItemFormatToDictionary:(NSDictionary *)dictionaryToConvert;- (NSMutableDictionary *)dictionaryToSecItemFormat:(NSDictionary *)dictionaryToConvert;// Updates the item in the keychain, or adds it if it doesn&apos;t exist.- (void)writeToKeychain;@end@implementation KeychainItemWrapper@synthesize keychainItemData, genericPasswordQuery;- (id)initWithAccount:(NSString *)account service:(NSString *)service accessGroup:(NSString *) accessGroup;&#123; if (self = [super init]) &#123; NSAssert(account != nil || service != nil, @&quot;Both account and service are nil. Must specifiy at least one.&quot;); // Begin Keychain search setup. The genericPasswordQuery the attributes kSecAttrAccount and // kSecAttrService are used as unique identifiers differentiating keychain items from one another genericPasswordQuery = [[NSMutableDictionary alloc] init]; [genericPasswordQuery setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass]; [genericPasswordQuery setObject:account forKey:(id)kSecAttrAccount]; [genericPasswordQuery setObject:service forKey:(id)kSecAttrService]; // The keychain access group attribute determines if this item can be shared // amongst multiple apps whose code signing entitlements contain the same keychain access group. if (accessGroup != nil) &#123;#if TARGET_IPHONE_SIMULATOR // Ignore the access group if running on the iPhone simulator. // // Apps that are built for the simulator aren&apos;t signed, so there&apos;s no keychain access group // for the simulator to check. This means that all apps can see all keychain items when run // on the simulator. // // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the // simulator will return -25243 (errSecNoAccessForItem).#else [genericPasswordQuery setObject:accessGroup forKey:(id)kSecAttrAccessGroup];#endif &#125; // Use the proper search constants, return only the attributes of the first match. [genericPasswordQuery setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit]; [genericPasswordQuery setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnAttributes]; NSDictionary *tempQuery = [NSDictionary dictionaryWithDictionary:genericPasswordQuery]; NSMutableDictionary *outDictionary = nil; if (! SecItemCopyMatching((CFDictionaryRef)tempQuery, (CFTypeRef *)&amp;outDictionary) == noErr) &#123; // Stick these default values into keychain item if nothing found. [self resetKeychainItem]; //Adding the account and service identifiers to the keychain [keychainItemData setObject:account forKey:(id)kSecAttrAccount]; [keychainItemData setObject:service forKey:(id)kSecAttrService]; if (accessGroup != nil) &#123;#if TARGET_IPHONE_SIMULATOR // Ignore the access group if running on the iPhone simulator. // // Apps that are built for the simulator aren&apos;t signed, so there&apos;s no keychain access group // for the simulator to check. This means that all apps can see all keychain items when run // on the simulator. // // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the // simulator will return -25243 (errSecNoAccessForItem).#else [keychainItemData setObject:accessGroup forKey:(id)kSecAttrAccessGroup];#endif &#125; &#125; else &#123; // load the saved data from Keychain. self.keychainItemData = [self secItemFormatToDictionary:outDictionary]; &#125; [outDictionary release]; &#125; return self;&#125;- (id)initWithIdentifier: (NSString *)identifier accessGroup:(NSString *) accessGroup;&#123; if (self = [super init]) &#123; // Begin Keychain search setup. The genericPasswordQuery leverages the special user // defined attribute kSecAttrGeneric to distinguish itself between other generic Keychain // items which may be included by the same application. genericPasswordQuery = [[NSMutableDictionary alloc] init]; [genericPasswordQuery setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass]; [genericPasswordQuery setObject:identifier forKey:(id)kSecAttrGeneric]; // The keychain access group attribute determines if this item can be shared // amongst multiple apps whose code signing entitlements contain the same keychain access group. if (accessGroup != nil) &#123;#if TARGET_IPHONE_SIMULATOR // Ignore the access group if running on the iPhone simulator. // // Apps that are built for the simulator aren&apos;t signed, so there&apos;s no keychain access group // for the simulator to check. This means that all apps can see all keychain items when run // on the simulator. // // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the // simulator will return -25243 (errSecNoAccessForItem).#else [genericPasswordQuery setObject:accessGroup forKey:(id)kSecAttrAccessGroup];#endif &#125; // Use the proper search constants, return only the attributes of the first match. [genericPasswordQuery setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit]; [genericPasswordQuery setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnAttributes]; NSDictionary *tempQuery = [NSDictionary dictionaryWithDictionary:genericPasswordQuery]; NSMutableDictionary *outDictionary = nil; if (! SecItemCopyMatching((CFDictionaryRef)tempQuery, (CFTypeRef *)&amp;outDictionary) == noErr) &#123; // Stick these default values into keychain item if nothing found. [self resetKeychainItem]; // Add the generic attribute and the keychain access group. [keychainItemData setObject:identifier forKey:(id)kSecAttrGeneric]; if (accessGroup != nil) &#123;#if TARGET_IPHONE_SIMULATOR // Ignore the access group if running on the iPhone simulator. // // Apps that are built for the simulator aren&apos;t signed, so there&apos;s no keychain access group // for the simulator to check. This means that all apps can see all keychain items when run // on the simulator. // // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the // simulator will return -25243 (errSecNoAccessForItem).#else [keychainItemData setObject:accessGroup forKey:(id)kSecAttrAccessGroup];#endif &#125; &#125; else &#123; // load the saved data from Keychain. self.keychainItemData = [self secItemFormatToDictionary:outDictionary]; &#125; [outDictionary release]; &#125; return self;&#125;- (void)dealloc&#123; [keychainItemData release]; [genericPasswordQuery release]; [super dealloc];&#125;- (void)setObject:(id)inObject forKey:(id)key &#123; if (inObject == nil) return; id currentObject = [keychainItemData objectForKey:key]; if (![currentObject isEqual:inObject]) &#123; [keychainItemData setObject:inObject forKey:key]; [self writeToKeychain]; &#125;&#125;- (id)objectForKey:(id)key&#123; return [keychainItemData objectForKey:key];&#125;- (void)resetKeychainItem&#123; OSStatus junk = noErr; if (!keychainItemData) &#123; self.keychainItemData = [[NSMutableDictionary alloc] init]; &#125; else if (keychainItemData) &#123; NSMutableDictionary *tempDictionary = [self dictionaryToSecItemFormat:keychainItemData]; junk = SecItemDelete((CFDictionaryRef)tempDictionary); NSAssert( junk == noErr || junk == errSecItemNotFound, @&quot;Problem deleting current dictionary.&quot; ); &#125; // Default attributes for keychain item. [keychainItemData setObject:@&quot;&quot; forKey:(id)kSecAttrAccount]; [keychainItemData setObject:@&quot;&quot; forKey:(id)kSecAttrLabel]; [keychainItemData setObject:@&quot;&quot; forKey:(id)kSecAttrDescription]; // Default data for keychain item. [keychainItemData setObject:@&quot;&quot; forKey:(id)kSecValueData];&#125;- (NSMutableDictionary *)dictionaryToSecItemFormat:(NSDictionary *)dictionaryToConvert&#123; // The assumption is that this method will be called with a properly populated dictionary // containing all the right key/value pairs for a SecItem. // Create a dictionary to return populated with the attributes and data. NSMutableDictionary *returnDictionary = [NSMutableDictionary dictionaryWithDictionary:dictionaryToConvert]; // Add the Generic Password keychain item class attribute. [returnDictionary setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass]; // Convert the NSString to NSData to meet the requirements for the value type kSecValueData. // This is where to store sensitive data that should be encrypted. NSString *passwordString = [dictionaryToConvert objectForKey:(id)kSecValueData]; [returnDictionary setObject:[passwordString dataUsingEncoding:NSUTF8StringEncoding] forKey:(id)kSecValueData]; return returnDictionary;&#125;- (NSMutableDictionary *)secItemFormatToDictionary:(NSDictionary *)dictionaryToConvert&#123; // The assumption is that this method will be called with a properly populated dictionary // containing all the right key/value pairs for the UI element. // Create a dictionary to return populated with the attributes and data. NSMutableDictionary *returnDictionary = [NSMutableDictionary dictionaryWithDictionary:dictionaryToConvert]; // Add the proper search key and class attribute. [returnDictionary setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnData]; [returnDictionary setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass]; // Acquire the password data from the attributes. NSData *passwordData = NULL; if (SecItemCopyMatching((CFDictionaryRef)returnDictionary, (CFTypeRef *)&amp;passwordData) == noErr) &#123; // Remove the search, class, and identifier key/value, we don&apos;t need them anymore. [returnDictionary removeObjectForKey:(id)kSecReturnData]; // Add the password to the dictionary, converting from NSData to NSString. NSString *password = [[[NSString alloc] initWithBytes:[passwordData bytes] length:[passwordData length] encoding:NSUTF8StringEncoding] autorelease]; [returnDictionary setObject:password forKey:(id)kSecValueData]; &#125; else &#123; // Don&apos;t do anything if nothing is found. NSAssert(NO, @&quot;Serious error, no matching item found in the keychain.\\n&quot;); &#125; [passwordData release]; return returnDictionary;&#125;- (void)writeToKeychain&#123; NSDictionary *attributes = NULL; NSMutableDictionary *updateItem = NULL; OSStatus result; if (SecItemCopyMatching((CFDictionaryRef)genericPasswordQuery, (CFTypeRef *)&amp;attributes) == noErr) &#123; // First we need the attributes from the Keychain. updateItem = [NSMutableDictionary dictionaryWithDictionary:attributes]; // Second we need to add the appropriate search key/values. [updateItem setObject:[genericPasswordQuery objectForKey:(id)kSecClass] forKey:(id)kSecClass]; // Lastly, we need to set up the updated attribute list being careful to remove the class. NSMutableDictionary *tempCheck = [self dictionaryToSecItemFormat:keychainItemData]; [tempCheck removeObjectForKey:(id)kSecClass]; #if TARGET_IPHONE_SIMULATOR // Remove the access group if running on the iPhone simulator. // // Apps that are built for the simulator aren&apos;t signed, so there&apos;s no keychain access group // for the simulator to check. This means that all apps can see all keychain items when run // on the simulator. // // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the // simulator will return -25243 (errSecNoAccessForItem). // // The access group attribute will be included in items returned by SecItemCopyMatching, // which is why we need to remove it before updating the item. [tempCheck removeObjectForKey:(id)kSecAttrAccessGroup];#endif // An implicit assumption is that you can only update a single item at a time. result = SecItemUpdate((CFDictionaryRef)updateItem, (CFDictionaryRef)tempCheck); NSAssert( result == noErr, @&quot;Couldn&apos;t update the Keychain Item.&quot; ); &#125; else &#123; // No previous item found; add the new one. result = SecItemAdd((CFDictionaryRef)[self dictionaryToSecItemFormat:keychainItemData], NULL); NSAssert( result == noErr, @&quot;Couldn&apos;t add the Keychain Item.&quot; ); &#125;&#125;@end ###应用到项目中： 123456789101112131415 //从Keychain中取出deviceCode(设备的唯一标示码) KeychainItemWrapper *keychainItem = [[KeychainItemWrapper alloc] initWithAccount:@&quot;Identfier&quot; service:@&quot;AppName&quot; accessGroup:nil]; NSString *string = [keychainItem objectForKey: (__bridge id)kSecAttrGeneric]; if([string isEqualToString:@&quot;&quot;] || !string)&#123;// 如果不存在就创建uuid，并存处在keychain中 CFUUIDRef uuidRef = CFUUIDCreate (kCFAllocatorDefault); string = (NSString *)CFBridgingRelease(CFUUIDCreateString (kCFAllocatorDefault,uuidRef)); //保存数据 [keychainItem setObject:string forKey:(__bridge id)kSecAttrGeneric]; &#125; // 从keychain中读取uuid KeychainItemWrapper *keychainItemm = [[KeychainItemWrapper alloc] initWithAccount:@&quot;Identfier&quot; service:@&quot;AppName&quot; accessGroup:nil]; NSString *deviceCode = [keychainItemm objectForKey: (__bridge id)kSecAttrGeneric]; ##ps: 使用KeychainItemWrapper时要引入&lt;Security/Security.h&gt; 设置非arc编译环境target&gt;build&gt;phases&gt;compile sources下找到KeychainItemWrapper.m文件双击写入-fno-objc-arc 当KeychainItemWrapper *keychainItem = [[KeychainItemWrapper alloc] initWithAccount:@&quot;Identfier&quot; service:@&quot;AppName&quot; accessGroup:nil];这句代码中的accessGroup不等于nil时，要做以下操作： 例如加入你的accessGroup为YOUR_BUNDLE_SEED.com.yourcompany.userinfo 1.在项目相同的目录下创建KeychainAccessGroups.plist文件。该文件的结构是一个字典，其中中最顶层的节点必须是一个键为“keychain-access-groups”的Array，并且该Array中每一项都是一个描述分组的NSString。YOUR_BUNDLE_SEED.com.yourcompany.userinfo就是要设置的组名。如图: 2.在Target-Build Settings-Code Signing栏下的Code Signing Entitlements右侧添加KeychainAccessGroups.plist 如图： ###博主Demo 今天无意发现了通过Safiri获取UDID的终极解决方案，拿出来和大家分享 http://blog.csdn.net/zkdemon/article/details/50057515 http://www.skyfox.org/safari-ios-device-udid.html 技术交流群:494826724","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"RSA非对称加密","slug":"RSA非对称加密","date":"2015-12-24T09:53:36.000Z","updated":"2016-09-18T08:36:41.000Z","comments":true,"path":"2015/12/24/RSA非对称加密/","link":"","permalink":"https://devchao.com/2015/12/24/RSA非对称加密/","excerpt":"","text":"#RSA非对称加密 -by yacaocn 本文部分生成公钥和私钥部分参考了http://www.w2bc.com/article/62239另推荐一个项目https://github.com/reference/OpenSSLRSAWrapper ####I.生成公钥和私钥 1.终端输入openssl，进入openssl状态 2.生成一个1024位的私钥：genrsa -out private_key.pem 1024 3.利用私钥生成JAVA支持的PKCS8类型的私钥：pkcs8 -topk8 -inform PEM -in private_key.pem -outform PEM -nocrypt -out pkcs8_private_key.pem 3补充：如果想要加密的PKCS8私钥：pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM –nocrypt 按提示输入密码，就会在终端中打印出加密后的pkcs8私钥 4.生成JAVA支持的PKCS8二进制类型的私钥：pkcs8 -topk8 -inform PEM -in private_key.pem -outform DER -nocrypt -out pkcs8_private_key.der 5.生成公钥：rsa -in private_key.pem -pubout -out public_key.pem 6.生成iOS支持的der证书，其间用到了证书请求和自签署根证书 6.1.创建证书请求：req -new -out cert.csr -key private_key.pem （其间会要求填写国家地区公司信息等，随便填写OR认真填写都不影响证书使用） 6.2.创建X509的自签署跟证书（iOS支持X509，有效期3650天）：x509 -req -in cert.csr -out public_key.der -outform der -signkey private_key.pem -days 3650完成了以上的步骤后应该在你所在的目录下生成了6个文件，其中pem的文件都是文本类型的，都可以使用文本编辑器或者cat命令查看。der的都是二进制的文件了，看不了。 OC与java交互示例：https://github.com/BabyDuncan/RSA_OC_JAVA ####II.运用openSSL加密库1.下载openSSL库，这里我提供两种下载方式 官网下载 :下载openSSL 便捷下载（包括openSSL使用的示例代码）便捷下载openSSL为什么成为便捷下载呢？请看下面 2.编译openSSL静态库 ，这里我也提供两种方式 人工逐步编译，网上特别多编译方法，例如http://blog.csdn.net/kmyhy/article/details/6534067 自动编译 ， 自动编译需要便捷下载方式： 1234(1).打开终端cd到你下载的项目目录下。 (2).执行./build-libssl.sh (3).去吃个苹果等待一下，此过程有点长大约10分钟。 (4).完成后打开下载的项目目录你会发现多了两个文件夹 include、lib，其中include中存放的是openSSL源码，lib中存放的就是自动编译好的静态库，其中存放了四个文件libcrypto-tvOS.a、libcrypto.a 、libssl-tvOS.a 、libssl.a 下载博主的openSSL库 3.添加openSSL到我们的项目中 新建文件夹openSSL将include、lib两个文件夹copy到openSSL文件夹中。 将openSSL文件夹、private_key.pem、public_key.pem拖拽到我们的工程中，拖拽后的工程目录结构如下: 添加头文件搜索路径：target》build setting》Header search Paths中添加$(PROJECT_DIR)/openSSL,将后面的non-recursive改为recursive 在项目中的ViewController中添加#include #include 头文件测试是否添加成功 ####下面就把我们刚生成的private_key.pem和public_key.pem运用到项目中： 具体示例代码如下：并附上本人工程代码:下载作者代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331#import &quot;ViewController.h&quot;#include &lt;openssl/pem.h&gt;#include &lt;openssl/rsa.h&gt;#include &lt;openssl/md5.h&gt;//MD5生成#import &lt;CommonCrypto/CommonDigest.h&gt;#define FileHashDefaultChunkSizeForReadingData 1024*8#define kPublicKeyFile [[NSBundle mainBundle] pathForResource:@&quot;public_key&quot; ofType:@&quot;pem&quot;] //公钥路径#define kPrivateKeyFile [[NSBundle mainBundle] pathForResource:@&quot;private_key&quot; ofType:@&quot;pem&quot;] //私钥路径#define kContentTxt @&quot;kumadocs.com&quot;//需要加密数据@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //密文 unsigned char encrypted[1024]; bzero(encrypted, sizeof(encrypted)); //明文 char decrypted[1024]; //公钥和私钥文件 const char* pub_key = [kPublicKeyFile UTF8String]; const char* priv_key = [kPrivateKeyFile UTF8String]; // ------------------------------------------------------- // 利用公钥加密明文的过程 // ------------------------------------------------------- RSA *rsa1 = NULL; const char *contentChar = [kContentTxt UTF8String]; FILE* pub_fp=fopen(pub_key,&quot;r&quot;); if(pub_fp==NULL)&#123; printf(&quot;Open Failed!! The Pub_Key File : %s!\\n&quot;, pub_key); return ; &#125; // 从文件中读取公钥 rsa1 = PEM_read_RSA_PUBKEY(pub_fp, NULL, NULL, NULL); if(rsa1 == NULL)&#123; printf(&quot;Pub_Key Read Failure!!\\n&quot;); return ; &#125; if(strlen(contentChar) &gt;= RSA_size(rsa1)-41)&#123; printf(&quot;Encrypt Failed!!\\n&quot;); return ; &#125; fclose(pub_fp); // 用公钥加密 （如需私钥加密将如下函数换成RSA_private_encrypt即可） int state = RSA_public_encrypt (strlen(contentChar), (const unsigned char*)contentChar, encrypted, rsa1, RSA_PKCS1_PADDING); if( state == -1 )&#123; printf(&quot;Encrypt Failed!!&quot;); return ; &#125; // --------------------------- // 输出加密后的密文 NSString *encryptedTxt = @&quot;&quot;; for (int i = 0; i &lt; 128; i++) &#123;//注意128按需要的自行改 encryptedTxt = [encryptedTxt stringByAppendingFormat:@&quot;%02x&quot;,encrypted[i]]; &#125; NSLog(@&quot;encryptedTxt == 》 \\n\\n%@\\n\\n&quot;,encryptedTxt); // ------------------------------------------------------- // 利用私钥解密密文的过程 // ------------------------------------------------------- // 打开私钥文件 FILE* priv_fp=fopen(priv_key,&quot;r&quot;); if(priv_fp==NULL)&#123; printf(&quot;Open Failed!! The Priv_Key File :%s!\\n&quot;, priv_key); return ; &#125; // 从文件中读取私钥 RSA *rsa2 = PEM_read_RSAPrivateKey(priv_fp, NULL, NULL, NULL); if(rsa2==NULL)&#123; printf(&quot;Priv_Key Read Failure!!\\n&quot;); return ; &#125; // 用私钥解密 （如需公钥解密只需将如下函数改成RSA_public_decrypt即可） state = RSA_private_decrypt(state, encrypted, decrypted, rsa2, RSA_PKCS1_PADDING); if(state == -1)&#123; printf(&quot;Decrypt Failed!!\\n&quot;); return ; &#125; fclose(priv_fp); // 输出解密后的明文 decrypted[state]=0; printf(&quot;decrypted == 》%s\\n&quot;,decrypted); NSString *opensslMD5 = [self genaryMD5FromString:@&quot;12345&quot;]; NSLog(@&quot;openssl&gt;&gt;&gt;&gt;md5:%@&quot;,opensslMD5); NSString *commonDigestMD5 = [ViewController md5HexDigest:@&quot;12345&quot;]; NSLog(@&quot;commonDigestMD5 &gt;&gt;&gt;:%@&quot;,commonDigestMD5); /** * * 打印出来的结果 */ /* 2015-12-22 10:25:43.241 RSA_pem公钥私钥加密[1804:89084] encryptedTxt == 》8b4f003797194009716f7239bc336b8be80561ddc07bb0ce0498c6de0740244f4205c6cac19b49a461d0a1f927677507eb8c2261cc06eada177ea341008b559100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 decrypted == 》kumadocs.com 2015-12-22 10:25:43.253 RSA_pem公钥私钥加密[1804:89084] input string:12345 2015-12-22 10:25:43.253 RSA_pem公钥私钥加密[1804:89084] md5: 827ccb0eea8a706c4c34a16891f84e7b 2015-12-22 10:25:43.254 RSA_pem公钥私钥加密[1804:89084] openssl&gt;&gt;&gt;&gt;md5: 827ccb0eea8a706c4c34a16891f84e7b 2015-12-22 10:25:43.254 RSA_pem公钥私钥加密[1804:89084] commonDigestMD5 &gt;&gt;&gt;: 827ccb0eea8a706c4c34a16891f84e7b */ &#125;//openssl计算MD5-(NSString *)genaryMD5FromString:(NSString *)string&#123; // 输入参数 1 ：要生成 md5 值的字符串， NSString--&gt;uchar* unsigned char *inStrg = ( unsigned char *)[[string dataUsingEncoding : NSASCIIStringEncoding ] bytes]; // 输入参数 2 ：字符串长度 unsigned long lngth = [string length ]; // 输出参数 3 ：要返回的 md5 值， MD5_DIGEST_LENGTH 为 16bytes ， 128 bits unsigned char result[ MD5_DIGEST_LENGTH ]; // 临时 NSString 变量，用于把 uchar* 组装成可以显示的字符串： 2 个字符一 byte 的 16 进制数 NSMutableString *outStrg = [ NSMutableString string ]; // 调用 OpenSSL 函数 MD5 (inStrg, lngth, result); unsigned int i; for (i = 0; i &lt; MD5_DIGEST_LENGTH ; i++) &#123; [outStrg appendFormat : @&quot;%02x&quot; , result[i]]; &#125; NSLog ( @&quot;input string:%@&quot; ,string); NSLog ( @&quot;md5:%@&quot; ,outStrg); return outStrg;&#125;//系统函数计算MD5值如下+ (NSString *)md5HexDigest:(NSString*)password&#123; const char *original_str = [password UTF8String]; unsigned char result[CC_MD5_DIGEST_LENGTH]; CC_MD5(original_str, strlen(original_str), result); NSMutableString *hash = [NSMutableString string]; for (int i = 0; i &lt; 16; i++)&#123; [hash appendFormat:@&quot;%02X&quot;, result[i]]; &#125; NSString *mdfiveString = [hash lowercaseString]; // NSLog(@&quot;Encryption Result = %@&quot;,mdfiveString); return mdfiveString; &#125;//系统函数计算文件的MD5+(NSString*)getFileMD5WithPath:(NSString*)path&#123; return (__bridge_transfer NSString *)FileMD5HashCreateWithPath((__bridge CFStringRef)path, FileHashDefaultChunkSizeForReadingData); &#125;CFStringRef FileMD5HashCreateWithPath(CFStringRef filePath,size_t chunkSizeForReadingData) &#123; // Declare needed variables CFStringRef result = NULL; CFReadStreamRef readStream = NULL; // Get the file URL CFURLRef fileURL = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (CFStringRef)filePath, kCFURLPOSIXPathStyle, (Boolean)false); if (!fileURL) goto done; // Create and open the read stream readStream = CFReadStreamCreateWithFile(kCFAllocatorDefault, (CFURLRef)fileURL); if (!readStream) goto done; bool didSucceed = (bool)CFReadStreamOpen(readStream); if (!didSucceed) goto done; // Initialize the hash object CC_MD5_CTX hashObject; CC_MD5_Init(&amp;hashObject); // Make sure chunkSizeForReadingData is valid if (!chunkSizeForReadingData) &#123; chunkSizeForReadingData = FileHashDefaultChunkSizeForReadingData; &#125; // Feed the data to the hash object bool hasMoreData = true; while (hasMoreData) &#123; uint8_t buffer[chunkSizeForReadingData]; CFIndex readBytesCount = CFReadStreamRead(readStream,(UInt8 *)buffer,(CFIndex)sizeof(buffer)); if (readBytesCount == -1) break; if (readBytesCount == 0) &#123; hasMoreData = false; continue; &#125; CC_MD5_Update(&amp;hashObject,(const void *)buffer,(CC_LONG)readBytesCount); &#125; // Check if the read operation succeeded didSucceed = !hasMoreData; // Compute the hash digest unsigned char digest[CC_MD5_DIGEST_LENGTH]; CC_MD5_Final(digest, &amp;hashObject); // Abort if the read operation failed if (!didSucceed) goto done; // Compute the string result char hash[2 * sizeof(digest) + 1]; for (size_t i = 0; i &lt; sizeof(digest); ++i) &#123; snprintf(hash + (2 * i), 3, &quot;%02x&quot;, (int)(digest[i])); &#125; result = CFStringCreateWithCString(kCFAllocatorDefault,(const char *)hash,kCFStringEncodingUTF8); done: if (readStream) &#123; CFReadStreamClose(readStream); CFRelease(readStream); &#125; if (fileURL) &#123; CFRelease(fileURL); &#125; return result; &#125; 技术交流群:494826724","categories":[],"tags":[]},{"title":"3DTouch_Peek_Pop","slug":"3DTouch-Peek-Pop","date":"2015-12-22T00:51:14.000Z","updated":"2017-05-20T05:15:14.000Z","comments":true,"path":"2015/12/22/3DTouch-Peek-Pop/","link":"","permalink":"https://devchao.com/2015/12/22/3DTouch-Peek-Pop/","excerpt":"","text":"Getting Started with 3D Touch 详细信息请在在官方文档中搜索：Getting Started with 3D Touch Home screen quick action API:为你的app图标添加shortcuts(快捷方式),加快用户和你app的交互速度 UIKit peek and pop API:在你的应用程序内提供简单的访问、添加额外的内容，同事保持用户的上下文（context），使用它能够提供一个按压功能替换你应用程序原来的触摸和保持操作 UITouch force properties：可以提供一个自定义的压力，来响应用户的交互。 3Dtouch 具体做法如下 1.在appdelegate中的didFinishLaunchingWithOptions:方法中判断是否能够相应3Dtouch12345if (launchOptions[UIApplicationLaunchOptionsSourceApplicationKey] != nil) &#123; return NO;//shortcutItem 不为空证明要加载shortcutitem，不启动应用程序。 &#125;else&#123; return YES; &#125; 静态quick action：验证3DTouch 是否可用（self的isa指向viewController实例）仅作检验使用 123456if (self.traitCollection.forceTouchCapability == UIForceTouchCapabilityAvailable) &#123; NSLog(@&quot;3dtouch availabe&quot;); &#125;else&#123; NSLog(@&quot;3dtouch not availabe&quot;); &#125; 2.在plist中添加如下配置创建静态的shortcutItem：source code如下： 当用户点击了一个快速预览的按钮后：系统会启动（唤醒）你的app，UIKIT会调用app代理的application:performActionForShortcutItem:completionHandler:方法，在他的lanchOption中有UIApplicationLaunchOptionsShortcutItemKey，其中保存了UIApplicationShortcutItem这个对象。根据这些你可以做你自己的事情。 动态quick action： 2.在代码中动态创建shortcutItem 动态的shortcutItem 用UIApplicationShortcutItem, UIMutableApplicationShortcutItem, and UIApplicationShortcutIcon 这些类创建 用UIApplication 对象的shortcutItems属性，为你的app添加动态的quick actions。创建示例 1234567891011121314151617 -(void)createDynamicShortcutItem&#123; //动态创建UIApplicationShortcutItem //1. 创建一个图标的icon UIApplicationShortcutIcon *icon = [UIApplicationShortcutIcon iconWithTemplateImageName:@&quot;imageName&quot;]; //2.创建一个系统类型字符串 NSString *itemType = [NSString stringWithFormat:@&quot;%ld&quot;,(long)UIApplicationShortcutIconTypeSearch]; //3.创建一个item对象 UIApplicationShortcutItem *item = [[UIApplicationShortcutItem alloc]initWithType:itemType localizedTitle:@&quot;搜索&quot; localizedSubtitle:@&quot;可以自定义搜索哦&quot; icon:icon userInfo:nil]; UIApplication *application = [UIApplication sharedApplication]; NSArray *array = application.shortcutItems; NSMutableArray *mutShortItems = [NSMutableArray arrayWithArray:array]; [mutShortItems addObject:item]; application.shortcutItems = mutShortItems; &#125; 3.执行application:performActionForShortcutItem:completionHandler方法1234567891011- (void)application:(UIApplication *)application performActionForShortcutItem:(nonnull UIApplicationShortcutItem *)shortcutItem completionHandler:(nonnull void (^)(BOOL))completionHandler&#123; switch ([shortcutItem.type integerValue]) &#123; case 5: NSLog(@&quot;selected UIApplicationShortcutIconTypeSearch &quot;); break; default: break; &#125;&#125; UIKit Peek and Pop1.注册一个peek 和 pop 控制器使其支持peek and pop，并使其遵守UIViewControllerPreviewingDelegate代理协议1[self registerForPreviewingWithDelegate:self sourceView:self.view]; 2.实现UIViewControllerPreviewingDelegate的peek和pop代理方法 新建一个MYPreviewController继承自UIViewController，用于弹出的视图 123456789101112131415161718- (nullable UIViewController *)previewingContext:(id &lt;UIViewControllerPreviewing&gt;)previewingContext viewControllerForLocation:(CGPoint)location NS_AVAILABLE_IOS(9_0)&#123;// peek MYPreviewController *childVC = [[MYPreviewController alloc] init]; childVC.preferredContentSize = CGSizeMake(0.0,300); CGRect rect = CGRectMake(10, location.y - 10, self.view.frame.size.width - 20,20); previewingContext.sourceRect = rect; return childVC; &#125;- (void)previewingContext:(id &lt;UIViewControllerPreviewing&gt;)previewingContext commitViewController:(UIViewController *)viewControllerToCommit NS_AVAILABLE_IOS(9_0)&#123;// pop [self showViewController:viewControllerToCommit sender:self]; &#125; 解释： sourceRect是peek触发时的高亮区域。这个区域内的View会高亮显示，其余的会模糊掉。 效果解释： 轻按压击屏幕后出现模糊的横条。 重压屏幕后弹出黄色视图。 3.实现peek controller 上滑出现快捷按钮-peek quick action 在MYPreviewController中重写UIViewController的- (NSArray","categories":[],"tags":[]},{"title":"LocalNotifycation","slug":"LocalNotifycation","date":"2015-12-16T02:39:20.000Z","updated":"2016-09-18T08:35:43.000Z","comments":true,"path":"2015/12/16/LocalNotifycation/","link":"","permalink":"https://devchao.com/2015/12/16/LocalNotifycation/","excerpt":"","text":"#IOS本地通知 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#import &quot;AppDelegate.h&quot;@interface AppDelegate ()@property(nonatomic,strong) NSDateComponents *dateComponets;@property(nonatomic,strong) UILocalNotification *localNoti;@property(nonatomic) NSInteger i;@end@implementation AppDelegate-(void)addMinute:(NSTimer *)sender&#123; self.localNoti.fireDate = [self.localNoti.fireDate dateByAddingTimeInterval:100]; self.localNoti.timeZone = [NSTimeZone defaultTimeZone]; [[UIApplication sharedApplication] scheduleLocalNotification:self.localNoti]; NSLog(@&quot;%@&quot;,self.localNoti.fireDate);&#125;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. CGFloat systemVersion = [[UIDevice currentDevice].systemVersion floatValue]; if (systemVersion &gt;= 8.0) &#123; UIUserNotificationType types = UIUserNotificationTypeAlert | UIUserNotificationTypeBadge | UIUserNotificationTypeSound; UIUserNotificationSettings *setting = [UIUserNotificationSettings settingsForTypes:types categories:nil]; [[UIApplication sharedApplication]registerUserNotificationSettings:setting]; &#125; UILocalNotification *localNoti = [[UILocalNotification alloc]init]; self.localNoti = localNoti; if (nil != localNoti) &#123; NSCalendar *calendar = [NSCalendar autoupdatingCurrentCalendar]; NSDateComponents *dateComponets = [[NSDateComponents alloc]init]; dateComponets.year = 2015; dateComponets.month = 12; dateComponets.day = 11; dateComponets.hour = 12; dateComponets.minute = 30; self.dateComponets = dateComponets; NSDate *date = [calendar dateFromComponents:dateComponets]; NSTimer *timer = [NSTimer timerWithTimeInterval:3*60 target:self selector:@selector(addMinute:) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]; localNoti.fireDate = date; localNoti.timeZone = [NSTimeZone defaultTimeZone]; localNoti.alertTitle = @&quot;提示！&quot;; localNoti.alertBody = @&quot;该吃饭了！&quot;; localNoti.alertAction = @&quot;查看！&quot;; localNoti.soundName = UILocalNotificationDefaultSoundName; localNoti.applicationIconBadgeNumber = 1; NSDictionary *userinfo = [NSDictionary dictionaryWithObject:@&quot;你好！&quot; forKey:@&quot;nihao&quot;]; localNoti.userInfo = userinfo; [[UIApplication sharedApplication] scheduleLocalNotification:localNoti]; //收到通知 UILocalNotification *not = [launchOptions objectForKey:UIApplicationLaunchOptionsLocalNotificationKey]; if (not) &#123; NSDictionary *dic = not.userInfo; NSString *str = dic[@&quot;nihao&quot;]; NSLog(@&quot;%@&quot;,str); &#125; &#125; return YES;&#125;-(void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification&#123; //收到通知 if (notification) &#123; NSDictionary *dic = notification.userInfo; NSString *str = dic[@&quot;nihao&quot;]; NSLog(@&quot;%@&quot;,str); &#125;&#125;@end 下载代码》》下载代码 技术交流群:494826724","categories":[],"tags":[]},{"title":"RemoteNotifycation","slug":"RemoteNotifycation","date":"2015-12-16T02:37:44.000Z","updated":"2016-09-18T08:36:27.000Z","comments":true,"path":"2015/12/16/RemoteNotifycation/","link":"","permalink":"https://devchao.com/2015/12/16/RemoteNotifycation/","excerpt":"","text":"#ios远程通知 步骤 1.注册通知类型 2.注册远程通知[[UIApplication sharedApplication] registerForRemoteNotifications]; 3.如果注册成功，APNS返回device Token给设备，iOS操作系统把device Token传递给app 代理，在app代理方法application:didRegisterForRemoteNotificationsWithDeviceToken:中获得device Token，app以二进制格式编码，并把其传递给app的服务提供者，如果获得device Token时 出现问题操作系统就会把错误信息传递给app代理方法application:didFailToRegisterForRemoteNotificationsWithError:error描述了错误产生的原因。注： 如果蜂窝移动网、WiFi 不可用下面两个app代理方法将会调用application:didRegisterForRemoteNotificationsWithDeviceToken: application:didFailToRegisterForRemoteNotificationsWithError: 4.把device Token提供给app推送提供者。 5.当app不在前台运行时，传递信息依靠呈现一个弹窗、播放一个声音、标记app一个徽章，或许现实一个很多的按钮给用户点击。当用户点击一个按钮时（ios8以后），iOS会调用application:handleActionWithIdentifier:forRemoteNotification:completionHandler: 6.如果app正在前台运行接收到通知则会调用application:didReceiveRemoteNotification:fetchCompletionHandler不能实现，则会实现application:didReceiveRemoteNotification:方法,如果你想要你的app在程序前台运行时，获取到远程通知必须实现这个方法：application:didReceiveRemoteNotification:fetchCompletionHandler:此时代理开始安排下载等待的数据、消息、其他的元素；一个字典值在第二个参数中传递过来 ####代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123//// AppDelegate.m// RemoteNotificationDemo//// Created by NavchinaMacBook on 15/8/4.// Copyright (c) 2015年 NavchinaMacBook. All rights reserved.//#import &quot;AppDelegate.h&quot;@interface AppDelegate ()@property(nonatomic) BOOL registered;@end@implementation AppDelegate#pragma mark - 注册远程通知//用户点击默认按钮、app图标时调用此方法。- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;//注册通知事件 // 第一个事件 UIMutableUserNotificationAction *acceptAction = [[UIMutableUserNotificationAction alloc]init]; //创建一个identify用于标记action acceptAction.identifier = @&quot;ACCEPT_IDENTIFIER&quot;; acceptAction.title = @&quot;Accept&quot;; //如果activationMode设置为UIUserNotificationActivationModeForeground，则authenticationRequired将被系统强制设置为yes，将忽视后面的设置。 //选择在什么情况加激活应用程序。 acceptAction.activationMode = UIUserNotificationActivationModeBackground; //提示字体颜色：yes ：红色 no :蓝色 acceptAction.destructive = NO; //是否需要密码验证，yes需要，no：不需要 acceptAction.authenticationRequired = NO; // 第二个事件 UIMutableUserNotificationAction *meetingAction = [[UIMutableUserNotificationAction alloc]init]; //创建一个identify用于标记action meetingAction.identifier = @&quot;MEETING_IDENTIFIER&quot;; meetingAction.title = @&quot;OK&quot;; //如果activationMode设置为UIUserNotificationActivationModeForeground，则authenticationRequired将被系统强制设置为yes，将忽视后面的设置。 //选择在什么情况加激活应用程序。 meetingAction.activationMode = UIUserNotificationActivationModeBackground; //提示字体颜色：yes ：红色 no :蓝色 meetingAction.destructive = YES; //是否需要密码验证，yes需要，no：不需要 meetingAction.authenticationRequired = NO; //添加到不同的类别中去 UIMutableUserNotificationCategory *inviteCategory = [[UIMutableUserNotificationCategory alloc]init]; inviteCategory.identifier = @&quot;INVITE_CATEGORY&quot;; [inviteCategory setActions:@[acceptAction,meetingAction] forContext:UIUserNotificationActionContextDefault]; [inviteCategory setActions:@[acceptAction,meetingAction] forContext:UIUserNotificationActionContextMinimal]; //注册通知类别 NSSet *categories = [NSSet setWithObjects:inviteCategory,/*alarmCategory*/ nil]; CGFloat systemVersion = [[UIDevice currentDevice].systemVersion floatValue]; if (systemVersion &gt;= 8.0) &#123; //注册通知类型 UIUserNotificationType types = UIUserNotificationTypeBadge | UIUserNotificationTypeSound | UIUserNotificationTypeAlert; UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:types categories:categories]; [[UIApplication sharedApplication] registerUserNotificationSettings:settings]; &#125;else&#123; [[UIApplication sharedApplication] registerForRemoteNotificationTypes:(UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeSound)]; &#125; //向ios操作系统注册远程通知，以获取decice Token. [[UIApplication sharedApplication] registerForRemoteNotifications]; return YES;&#125;-(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken&#123; NSLog(@&quot;%@&quot;,deviceToken); const void *deviceTokenBytes = [deviceToken bytes]; //注册成功 self.registered = YES; //发送给本地服务器// [self sendProviderDeviceToken:deviceTokenBytes]; &#125;-(void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error&#123; //注册device Token时失败。 NSLog(@&quot;%@&quot;,error);&#125;#pragma mark - 用户点击按钮后执行方法-(void)handleAcceptActionWithNotification:(NSDictionary *)userInfo&#123; //设置用户点击按钮后程序需要执行的操作。&#125;#pragma mark - 收到远程通知//收到用户点击事件 （应用程序在后台，用户点击一个按钮时触发）-(void)application:(UIApplication *)application handleActionWithIdentifier:(NSString *)identifier forRemoteNotification:(NSDictionary *)userInfo completionHandler:(void (^)())completionHandler&#123; //具体实现 if ([identifier isEqualToString:@&quot;ACCEPT_IDENTIFIER&quot;]) &#123; [self handleAcceptActionWithNotification:userInfo]; &#125; if ([identifier isEqualToString:@&quot;MEETING_IDENTIFIER&quot;]) &#123; //执行具体操作。 &#125; completionHandler();&#125;//应用程序在前台收到远程通知时会调用此方法，如果此方法不被实现则会调用application:didReceiveRemoteNotification-(void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler&#123; NSString *itemName = [userInfo objectForKey:@&quot;ToDoItemKey&quot;]; //具体的实现 application.applicationIconBadgeNumber = 3; &#125;-(void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo&#123; &#125;@end 附件》》下载源码 技术交流群:494826724","categories":[],"tags":[]},{"title":"AES对称加密","slug":"AES对称加密","date":"2015-12-11T02:26:30.000Z","updated":"2016-09-18T08:33:11.000Z","comments":true,"path":"2015/12/11/AES对称加密/","link":"","permalink":"https://devchao.com/2015/12/11/AES对称加密/","excerpt":"","text":"#AES对称加密 - by yachaocn 摘要 AES 是一个迭代的、对称密钥分组的密码,它可以使用128、192 和 256 位密钥,并且用 128 位(16字节)分组加密和解密数据。此处采用256位进行加密。 ####1.创建NSData的一个类别Encryption .h文件 123456#import &lt;Foundation/Foundation.h&gt;@interface NSData (Encryption)- (NSData *)AES256ParmEncryptWithKey:(NSString *)key; //加密- (NSData *)AES256ParmDecryptWithKey:(NSString *)key; //解密 @end .m文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#import &quot;NSData+Encryption.h&quot;#import &lt;CommonCrypto/CommonCrypto.h&gt;@implementation NSData (Encryption)- (NSData *)AES256ParmEncryptWithKey:(NSString *)key //加密&#123; char keyPtr[kCCKeySizeAES256+1]; bzero(keyPtr, sizeof(keyPtr)); [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding]; NSUInteger dataLength = [self length]; size_t bufferSize = dataLength + kCCBlockSizeAES128; void *buffer = malloc(bufferSize); size_t numBytesEncrypted = 0; CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmAES128, kCCOptionPKCS7Padding | kCCOptionECBMode, keyPtr, kCCBlockSizeAES128, NULL, [self bytes], dataLength, buffer, bufferSize, &amp;numBytesEncrypted); if (cryptStatus == kCCSuccess) &#123; return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted]; &#125; free(buffer); return nil; &#125;- (NSData *)AES256ParmDecryptWithKey:(NSString *)key //解密&#123; char keyPtr[kCCKeySizeAES256+1]; bzero(keyPtr, sizeof(keyPtr)); [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding]; NSUInteger dataLength = [self length]; size_t bufferSize = dataLength + kCCBlockSizeAES128; void *buffer = malloc(bufferSize); size_t numBytesDecrypted = 0; CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt, kCCAlgorithmAES128, kCCOptionPKCS7Padding | kCCOptionECBMode, keyPtr, kCCBlockSizeAES128, NULL, [self bytes], dataLength, buffer, bufferSize, &amp;numBytesDecrypted); if (cryptStatus == kCCSuccess) &#123; return [NSData dataWithBytesNoCopy:buffer length:numBytesDecrypted]; &#125; free(buffer); return nil;&#125;@end 调用测试 123456789101112 NSString *str = @&quot;你好&quot;; NSData *data = [str dataUsingEncoding:NSUTF8StringEncoding]; // 加密 NSString *key = @&quot;535541213&quot;; NSData *encryptionData = [data AES256ParmEncryptWithKey:key]; NSLog(@&quot;%@加密后数据：%@&quot;,data,encryptionData); //解密 NSData *deData = [encryptionData AES256ParmDecryptWithKey:key]; NSString *deStr = [[NSString alloc]initWithData:deData encoding:NSUTF8StringEncoding]; NSLog(@&quot;解密后数据：%@&quot;,deStr); 本人代码：下载代码 技术交流群:494826724","categories":[],"tags":[]},{"title":"ios9画中画","slug":"iOS9画中画","date":"2015-11-27T05:51:27.000Z","updated":"2016-09-18T08:34:23.000Z","comments":true,"path":"2015/11/27/iOS9画中画/","link":"","permalink":"https://devchao.com/2015/11/27/iOS9画中画/","excerpt":"","text":"#画中画 ####如果想要你的视频播放支持画中画，必须确保你的app具有以下配置: 1.设置你的Base SDK 为 “Latest iOS,” 2.设置你的Capabilities中的 Background Modes 为Audio, AirPlay and Picture in Picture。 3.确保你的app视频播放会话（session）采用了合适的类别（category），例如：AVAudioSessionCategoryPlayback.接着app的视频播放必须采用AVKit, AV Foundation, or WebKit class，他决定了你的app视频播放的性质和你给用户的体验度。 4.AVKit framework的AVPlayerViewController类能够为用户提供一个进入画中画的按钮；如果你是使用AVKit支持画中画的，如果你想使某个视频的播放不支持画中画，你只需将player viewcontroller的allowsPictureInPicturePlayback属性设置为NO就可以了。 5。如果你想提供自己的ViewController和自定义的视频播放用户界面，那个AVKit也提供了AVPictureInPictureController类，它能够和AV Foundation下的AVPlayerLayer类一起使用来实现自定义。 假如你使用这种方式支持画中画的，那么如果你想要退出视频的画中画，请不要将AVPlayerLayer和AVPictureInPictureController相关联，只要你实例化AVPictureInPictureController和AVPlayerLayer,令playerlayer符合画中画，那么退出的方法是不执行实例。 1note: Media Player movie playback在ios9正式被弃用，将不能支持视频播放，无论是否支持画中画。 important: Picture in Picture is a feature that Apple intends to always be under user control. Invoke Picture in Picture only in response to a user’s explicit request to do so. If an app invokes Picture in Picture in a way that is not under the immediate direction of the user, especially upon the app moving to the background, the app will be rejected by the App Store. ios9中对于重在全屏播放的视频，当用户暗下home键或一个通知按钮时，视频将自动进入画中画模式，仅仅对支持画中画视频播放才有效，所以你需要如下配置你的视频播放视图： 1.确保你的app像上面描述的方式支持画中画。 2.通过指定你的视频播放view适应整个app窗口大小，来配置你的视频和全屏播放。 1tips:用户可以在Settings &gt; General &gt; Multitasking &gt; Persistent Video Overlay中禁用画中画模式，所以在你配置了所有的设置之后还不能支持画中画，请查看此设置。 ##最后附上本人画中画代码：下载代码 技术交流群:494826724","categories":[],"tags":[]},{"title":"未受信的企业级开发者","slug":"未受信的企业级开发者","date":"2015-11-26T07:27:16.000Z","updated":"2016-09-18T08:32:37.000Z","comments":true,"path":"2015/11/26/未受信的企业级开发者/","link":"","permalink":"https://devchao.com/2015/11/26/未受信的企业级开发者/","excerpt":"","text":"##安装企业分发应用程序报错：未受信的企业级开发者 #####前言：介于飞行员下载程序后无法打开程序的问题，特制作安装说明。 问题描述:下载程序并安装后，出现如下情形： 解决办法： 1、打开设置&gt;通用&gt;描述文件 如图： 2、打开后点击图中标注文件。 3、出现如下界面 4.点击图中红色圈中选项信任CHINA AVIATION NAVIGATION DATA CO.,LTD弹出如下界面： 5.点击信任按钮,跳转到如下图中 6.返回pad主界面，重新点击西藏航空，出现如下界面： ###最后恭喜你已成功解决此问题，是不是觉得自己很棒呢？偷偷笑一笑吧！ ##maded by yachaocn 技术交流群:494826724","categories":[],"tags":[]},{"title":"ios指纹验证","slug":"iOS指纹验证","date":"2015-11-26T07:22:36.000Z","updated":"2016-09-18T08:35:21.000Z","comments":true,"path":"2015/11/26/iOS指纹验证/","link":"","permalink":"https://devchao.com/2015/11/26/iOS指纹验证/","excerpt":"","text":"##ios指纹验证####前言 突然想研究一下苹果的指纹验证，想装逼一下，正好今天没事儿，于是心血来潮，捣鼓了一下，本来想找个指纹验证的算法的，找了半天无果，所以就乖乖的用苹果自带的吧。 #####废话少说开始了：1.在link Binary with libraries中添加LocalAuthentication.framework.库 2.在你的工程文件中导入头文件#import 3.验证方法如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566-(void)authenticateUser&#123; LAContext *context = [[LAContext alloc]init]; context.localizedFallbackTitle = @&quot;输入密码&quot;;// context.maxBiometryFailures = @(4); NSString *localizedReason = @&quot;Authentication is needed to access your note!&quot;; NSError *error; if ([context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&amp;error]) &#123; [context evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics localizedReason:localizedReason reply:^(BOOL success, NSError *error) &#123; if (success) &#123; NSLog(@&quot;指纹验证成功！&quot;); &#125;else&#123; NSLog(@&quot;%@&quot;,error.localizedDescription); switch (error.code) &#123; case LAErrorSystemCancel: NSLog(@&quot;Authentication was canceled by system&quot;); break; case LAErrorAuthenticationFailed: NSLog(@&quot;Authentication was not successful, because user failed to provide valid credentials.&quot;); break; case LAErrorUserCancel: &#123; NSLog(@&quot;Authentication was canceled by user&quot;); &#125; break; case LAErrorUserFallback: &#123; NSLog(@&quot;Authentication was canceled, because the user tapped the fallback button (Enter Password&quot;); &#125; break; default: break; &#125; &#125; &#125;]; &#125;else&#123; if (error) &#123; [self authenticateUser]; NSLog(@&quot;%@&quot;,error.localizedDescription); switch (error.code) &#123; case LAErrorTouchIDNotEnrolled: NSLog(@&quot;Authentication could not start, because Touch ID has no enrolled fingers.&quot;); break; case LAErrorPasscodeNotSet: NSLog(@&quot;Authentication could not start, because passcode is not set on the device&quot;); case LAErrorTouchIDNotAvailable: NSLog(@&quot;Authentication could not start, because Touch ID is not available on the device&quot;); default: NSLog(@&quot;TouchID not available&quot;); break; &#125; &#125; &#125; &#125; ####注释： AuthenticationFailed: 在用户没有提供正确验证的情况下返回该错误类型，例如使用一个错误的手指。 UserCancel:在用户有意终止验证的时候返回该类型。 UserFallback：在用户有意不使用TouchID验证并且回到自定义的输入验证方式时返回。 SystemCancel：在这种情况下，系统终止验证处理，因为另一个应用被激活了。 PasscodeNotSet：当用户没有在设备Settings中设定密码时返回。 TouchIDNotAvailable：设备不支持TouchID。 TouchIDNotEnrolled：在设备支持TouchID但没有录入指纹的时候返回。其他的就不多介绍了，不懂的直接翻译nslog打印的字符串吧！钦此。 技术交流群:494826724","categories":[],"tags":[]},{"title":"iOS_app分屏","slug":"iOS-app分屏","date":"2015-11-26T07:15:02.000Z","updated":"2017-03-23T07:03:02.000Z","comments":true,"path":"2015/11/26/iOS-app分屏/","link":"","permalink":"https://devchao.com/2015/11/26/iOS-app分屏/","excerpt":"","text":"#Slide Over and Split View Quick Start ####前言当你用xcode7新建工程时，默认是支持Slide Over and Split View的，如果你用老的工程在xocde7上面运行时是不支持分屏的，你需要做以下配置： - 设置Base SDK 为 “Latest iOS”。- 提供一个LaunchScreen.storyboard文件（ Creating a Launch Screen File in App Distribution Guide.）- 在工程的Info.plist文件中Supported interface orientations (iPad)键数组中加入支持四个方向的旋转如图： ######note:如果你不需要Slide Over and Split View 则在Info.plist中把UIRequiresFullScreen键设置为yes #####提示:如果你所有的都设置正确了，还是不能Slide Over and Split View，你学要去设置&gt;通用&gt;多任务中查看设置 以下是在分屏过程中可能遇到的屏幕类别如图： ####前提 你必须使用autolayout和sizeclass类布局你的app。 LaunchScreen.storyboard文件必须使用autolayout布局，用xcode7创建的app模板都会自动生成一个LaunchScreen.storyboard文件。 实现UITraitEnvironment 和 UIContentContainer 协议，用来实现屏幕特质和大小变化时，需要实现的自定义方法。 响应应用程序状态转换的委托方法（）。 ####下面介绍一些分屏过程中的状态 当用户移动分割器时，应用程序会调用applicationWillResignActive: 方法；当用户放开分割器时，系统会重新设定你app的大小，并获得一个快照，用来提供一个平滑的用户体验的过度。这是因为在用户放开分割器时你的app大小使不可知的，复杂的是用户可能在移动分割器的时候旋转屏幕。 用户一直移动分割器知道你的app消失，系统将会调用applicationDidEnterBackground: 方法。 ##最后提供给大家我的一个分屏代码示例点击获取代码 技术交流群:494826724","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://devchao.com/tags/iOS/"}]},{"title":"PSPDFKIT-PDF上画线","slug":"PSPDFKIT-PDF上画线","date":"2015-09-28T01:11:39.000Z","updated":"2016-09-18T08:36:11.000Z","comments":true,"path":"2015/09/28/PSPDFKIT-PDF上画线/","link":"","permalink":"https://devchao.com/2015/09/28/PSPDFKIT-PDF上画线/","excerpt":"","text":"1.PDF添加polayLine 12345678910111213141516171819[subclassingSection addContent:[PSContent contentWithTitle:@&quot;Programmatically add a PolyLine annotation&quot; block:^UIViewController *&#123; PSPDFDocument *document = [PSPDFDocument documentWithURL:hackerMagURL]; document.annotationSaveMode = PSPDFAnnotationSaveModeDisabled; // don&apos;t confuse other examples // add shape annotation if there isn&apos;t one already. NSUInteger targetPage = 0; if ([document annotationsForPage:targetPage type:PSPDFAnnotationTypePolyLine].count == 0) &#123; PSPDFPolyLineAnnotation *polyline = [PSPDFPolyLineAnnotation new]; polyline.points = @[[NSValue valueWithCGPoint:CGPointMake(52, 633)], [NSValue valueWithCGPoint:CGPointMake(67, 672)], [NSValue valueWithCGPoint:CGPointMake(131, 685)], [NSValue valueWithCGPoint:CGPointMake(178, 654)], [NSValue valueWithCGPoint:CGPointMake(115, 622)]]; polyline.color = [UIColor colorWithRed:0.0 green:1.f blue:0.f alpha:1.f]; polyline.fillColor = UIColor.yellowColor; polyline.lineEnd2 = PSPDFLineEndTypeClosedArrow; polyline.lineWidth = 5.f; polyline.page = targetPage; [document addAnnotations:@[polyline]]; &#125; PSPDFViewController *controller = [[PSPDFViewController alloc] initWithDocument:document]; controller.rightBarButtonItems = @[controller.searchButtonItem, controller.openInButtonItem, controller.viewModeButtonItem]; return controller; &#125;]]; 技术交流群:494826724","categories":[],"tags":[]},{"title":"UISearchViewController总结","slug":"UISearchViewController总结","date":"2015-09-01T07:20:14.000Z","updated":"2016-09-18T08:37:22.000Z","comments":true,"path":"2015/09/01/UISearchViewController总结/","link":"","permalink":"https://devchao.com/2015/09/01/UISearchViewController总结/","excerpt":"","text":"注：UISearchDisPlayController已被UISearchViewConreoller代替 应用效果：apple官方封装的搜索控件，实现了搜索时动态隐藏NavagationBar. 1.初始化UISearchViewConreoller 1UISearchController *searchController = [[UISearchController alloc]initWithSearchResultsController:nil]; 2.设置显示搜索结果的控制器 1searchController.searchResultsUpdater = self; 3.dimsBackgroundDuringPresentation 设置开始搜索时背景显示与否 1searchController.dimsBackgroundDuringPresentation = YES; 4.这是tableView的HeaderView为searchController的searchBar 1self.tablView.tableHeaderView = searchController.searchBar; 5.设置 searchController的searchBar大小自适应 1[searchController.searchBar sizeToFit]; 其他: 12searchController.searchBar.placeholder = @&quot;请输入地名：&quot;; searchController.searchBar.prompt = @&quot;输入要查找的人：&quot;; 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#import &quot;ViewController.h&quot;#import &lt;UIKit/UIKit.h&gt;@interface ViewController ()&lt;UITableViewDataSource, UITableViewDelegate, UISearchControllerDelegate, UISearchResultsUpdating&gt;//@property(nonatomic,strong) NSArray *items;//@property(nonatomic,strong) NSArray *searchResult;@property(nonatomic,strong) UITableView *tablView;@property(nonatomic,strong) NSArray *visableArray;@property(nonatomic,strong) NSArray *dataSourceArray;@property(nonatomic,strong) UISearchController *searVC;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.title = @&quot;LOL科普：地名大全&quot;; self.dataSourceArray = @[@&quot;国服第一臭豆腐 No.1 Stinky Tofu CN.&quot;, @&quot;瓦洛兰 Valoran&quot;, @&quot;德玛西亚 Demacia&quot;, @&quot;诺克萨斯 Noxus&quot;, @&quot;艾欧尼亚 Ionia&quot;, @&quot;皮尔特沃夫 Piltover&quot;, @&quot;弗雷尔卓德 Freijord&quot;, @&quot;班德尔城 Bandle City&quot;, @&quot;战争学院 The Institute of War&quot;, @&quot;祖安 Zaun&quot;, @&quot;卡拉曼达 Kalamanda&quot;, @&quot;蓝焰岛 Blue Flame Island&quot;, @&quot;哀嚎沼泽 Howling Marsh&quot;, @&quot;艾卡西亚 Icathia&quot;, @&quot;铁脊山脉 Ironspike Mountains&quot;, @&quot;库莽古丛林 Kumungu&quot;, @&quot;洛克法 Lokfar&quot;, @&quot;摩根小道 Morgon Pass&quot;, @&quot;塔尔贡山脉 Mountain Targon&quot;, @&quot;瘟疫丛林 Plague Jungles&quot;, @&quot;盘蛇河 Serpentine River&quot;, @&quot;恕瑞玛沙漠 Shurima Desert&quot;, @&quot;厄尔提斯坦 Urtistan&quot;, @&quot;巫毒之地 Voodoo Lands&quot;, @&quot;水晶之痕 Crystal Scar&quot;, @&quot;咆哮深渊 Howling Abyss&quot;, @&quot;熔岩洞窟 Magma Chambers&quot;, @&quot;试炼之地 Proving Grounds&quot;, @&quot;召唤师峡谷 Summoner&apos;s Rift&quot;, @&quot;扭曲丛林 Twisted Treeline&quot;]; // Do any additional setup after loading the view, typically from a nib. self.tablView = [[UITableView alloc]initWithFrame:self.view.frame]; self.tablView.delegate = self; self.tablView.dataSource = self; UISearchController *searchController = [[UISearchController alloc]initWithSearchResultsController:nil]; self.searVC = searchController;// searchController.delegate = self; searchController.searchResultsUpdater = self; searchController.searchBar.placeholder = @&quot;请输入地名：&quot;;// searchController.searchBar.prompt = @&quot;输入要查找的人：&quot;; searchController.dimsBackgroundDuringPresentation = YES; [self.view addSubview:self.tablView]; [searchController.searchBar sizeToFit]; self.tablView.tableHeaderView = searchController.searchBar; &#125;#pragma mark - UISearchResultsUpdating 代理// Called when the search bar&apos;s text or scope has changed or when the search bar becomes first responder.- (void)updateSearchResultsForSearchController:(UISearchController *)searchController&#123; NSPredicate *resultPredicate = [NSPredicate predicateWithFormat:@&quot;SELF contains[cd] %@&quot;, searchController.searchBar.text]; self.visableArray = [self.dataSourceArray filteredArrayUsingPredicate:resultPredicate]; [self.tablView reloadData];&#125;-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; if (_visableArray == nil || _visableArray.count == 0 ) &#123; _visableArray = self.dataSourceArray; &#125; return _visableArray.count;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; static NSString *ID = @&quot;cell&quot;; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; if (!cell) &#123; cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:ID]; &#125; cell.textLabel.text = _visableArray[indexPath.row]; return cell; &#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end 技术交流群:494826724","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://devchao.com/tags/ios/"}]},{"title":"ios3D绘图","slug":"3D绘图","date":"2015-08-26T02:28:17.000Z","updated":"2016-09-18T08:31:39.000Z","comments":true,"path":"2015/08/26/3D绘图/","link":"","permalink":"https://devchao.com/2015/08/26/3D绘图/","excerpt":"","text":"1.创建上下文 1234567891011EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3]; if (context == nil) &#123; context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2]; &#125; return context;2.设置上下文[EAGLContext setCurrentContext: myContext];3.用共有的shareGroup创建多个contextEAGLContext* firstContext = CreateBestEAGLContext();EAGLContext* secondContext = [[EAGLContext alloc] initWithAPI:[firstContext API] sharegroup: [firstContext sharegroup]]; 4.创建并配置一个GLKit viewMultisampling是一种抗锯齿,锯齿边缘光滑,改善图像质量在大多数3 d应用程序使用更多的内存和分段处理的成本如果你启用Multisampling,总是测试您的应用程序的性能,以确保它仍然是可以接受的 1234567891011// Create an OpenGL ES context and assign it to the view loaded from storyboard GLKView *view = (GLKView *)self.view; view.context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2]; // Configure renderbuffers created by the view view.drawableColorFormat = GLKViewDrawableColorFormatRGBA8888; view.drawableDepthFormat = GLKViewDrawableDepthFormat24; view.drawableStencilFormat = GLKViewDrawableStencilFormat8; // Enable multisampling view.drawableMultisample = GLKViewDrawableMultisample4X; 5.绘制图像 1234567891011121314 - (void)drawRect:(CGRect)rect&#123; // Clear the framebuffer glClearColor(0.0f, 0.0f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Draw using previously configured texture, shader, uniforms, and vertex array glBindTexture(GL_TEXTURE_2D, _planetTexture); glUseProgram(_diffuseShading); glUniformMatrix4fv(_uniformModelViewProjectionMatrix, 1, 0, _modelViewProjectionMatrix.m); glBindVertexArrayOES(_planetMesh); glDrawElements(GL_TRIANGLE_STRIP, 256, GL_UNSIGNED_SHORT);&#125; 技术交流群:494826724","categories":[],"tags":[]},{"title":"ios晃动事件","slug":"iOS中晃动事件","date":"2015-08-26T02:21:35.000Z","updated":"2016-09-18T08:35:29.000Z","comments":true,"path":"2015/08/26/iOS中晃动事件/","link":"","permalink":"https://devchao.com/2015/08/26/iOS中晃动事件/","excerpt":"","text":"晃动事件#####ios中晃动事件： 声明：在ios中事件的相应者链中指出：1.对于触摸事件响应者传给host View，远程控制事件（耳机线控等）、晃动事件则传递给第一响应者。 1.实现[UIApplication sharedApplication].applicationSupportsShakeToEdit = YES;告诉ios系统支持晃动事件。 2.重载-(BOOL)canBecomeFirstResponder{ return YES;}//指明控制器可以成为第一响应者。 3.分别在控制器中书写以下方法 -(void)viewDidAppear:(BOOL)animated { [super viewDidAppear:animated]; [self becomeFirstResponder]; } -(void)viewWillDisappear:(BOOL)animated { [super viewWillDisappear:animated]; [self resignFirstResponder]; } 4、viewController 方法 -(void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event{ if (motion == UIEventSubtypeMotionShake) { NSLog(@”%s”,func); } }12345678910111213141516-(void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event&#123; if (motion == UIEventSubtypeMotionShake) &#123; NSLog(@&quot;%s&quot;,__func__); &#125; &#125;-(void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event&#123; if (motion == UIEventSubtypeMotionShake) &#123; NSLog(@&quot;%s&quot;,__func__); &#125; &#125; 技术交流群:494826724","categories":[],"tags":[]},{"title":"ipad键盘参数","slug":"ipad键盘参数","date":"2015-08-26T02:20:56.000Z","updated":"2016-09-18T08:35:35.000Z","comments":true,"path":"2015/08/26/ipad键盘参数/","link":"","permalink":"https://devchao.com/2015/08/26/ipad键盘参数/","excerpt":"","text":"ipad键盘参数： 123456789NSConcreteNotification 0x15ddbe30 &#123;name = UIKeyboardWillShowNotification; userInfo = &#123; UIKeyboardAnimationCurveUserInfoKey = 7; UIKeyboardAnimationDurationUserInfoKey = &quot;0.25&quot;; UIKeyboardBoundsUserInfoKey = &quot;NSRect: &#123;&#123;0, 0&#125;, &#123;1024, 352&#125;&#125;&quot;; UIKeyboardCenterBeginUserInfoKey = &quot;NSPoint: &#123;512, 944&#125;&quot;; UIKeyboardCenterEndUserInfoKey = &quot;NSPoint: &#123;512, 592&#125;&quot;; UIKeyboardFrameBeginUserInfoKey = &quot;NSRect: &#123;&#123;0, 768&#125;, &#123;1024, 352&#125;&#125;&quot;; UIKeyboardFrameEndUserInfoKey = &quot;NSRect: &#123;&#123;0, 416&#125;, &#123;1024, 352&#125;&#125;&quot;;&#125;&#125; 技术交流群:494826724","categories":[],"tags":[]},{"title":"iOS注册app所支持的自定义文件类型","slug":"app注册默认打开类型","date":"2015-08-26T02:15:35.000Z","updated":"2016-09-18T08:33:17.000Z","comments":true,"path":"2015/08/26/app注册默认打开类型/","link":"","permalink":"https://devchao.com/2015/08/26/app注册默认打开类型/","excerpt":"","text":"iOS注册app所支持的自定义文件类型在plist文件中加入以下键值对： Document types imported type UTIs 对应的plist文件如下 123456789101112131415161718192021222324252627282930313233343536&lt;key&gt;CFBundleDocumentTypes&lt;/key&gt;&lt;array&gt; &lt;dict&gt; &lt;key&gt;CFBundleTypeName&lt;/key&gt; &lt;string&gt;db3&lt;/string&gt; &lt;key&gt;CFBundleTypeRole&lt;/key&gt; &lt;string&gt;Viewer&lt;/string&gt; &lt;key&gt;LSHandlerRank&lt;/key&gt; &lt;string&gt;Owner&lt;/string&gt; &lt;key&gt;LSItemContentTypes&lt;/key&gt; &lt;array&gt; &lt;string&gt;ZHC.TransationAirFileDemo.db&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt;&lt;/array&gt;&lt;key&gt;UTExportedTypeDeclarations&lt;/key&gt;&lt;array&gt; &lt;dict&gt; &lt;key&gt;UTTypeConformsTo&lt;/key&gt; &lt;array&gt; &lt;string&gt;public.plain-text&lt;/string&gt; &lt;string&gt;public.text&lt;/string&gt; &lt;/array&gt; &lt;key&gt;UTTypeDescription&lt;/key&gt; &lt;string&gt;ZHC db file&lt;/string&gt; &lt;key&gt;UTTypeIdentifier&lt;/key&gt; &lt;string&gt;ZHC.TransationAirFileDemo.db&lt;/string&gt; &lt;key&gt;UTTypeTagSpecification&lt;/key&gt; &lt;dict&gt; &lt;key&gt;public.filename-extension&lt;/key&gt; &lt;string&gt;db&lt;/string&gt; &lt;key&gt;public.mime-type&lt;/key&gt; &lt;string&gt;chemical/x-db&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt;&lt;/array&gt; 技术交流群:494826724","categories":[],"tags":[]},{"title":"安装xcode插件管理器","slug":"安装xcode插件管理器","date":"2015-08-26T02:11:35.000Z","updated":"2016-09-18T08:31:59.000Z","comments":true,"path":"2015/08/26/安装xcode插件管理器/","link":"","permalink":"https://devchao.com/2015/08/26/安装xcode插件管理器/","excerpt":"","text":"1.安装Xcode-command line toolshttp://railsapps.github.io/xcode-command-line-tools.html Xcode-command line tools 安装终端中键入：$ xcode-select –install 2.安装xcode插件管理器Alcatraz 1curl -fsSL https://raw.githubusercontent.com/supermarin/Alcatraz/deploy/Scripts/install.sh | sh 3.重启xcode 技术交流群:494826724","categories":[],"tags":[]}]}